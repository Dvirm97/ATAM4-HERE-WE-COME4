;Black = 2
;White = 1
;SkipC = 16
;SkipF = 22
;LeapC = 34
;LeapF = 44
;Empty = 0
;EdgeR = 16
;EdgeL = 0
;NEdgeR = 14
;NEdgeL = 2
;Win = 20
;Loss = 177760 ;which is actually -20
;Tie = 0
;Lowest = 177757; which is actually -21
;Highest = 21
;LCS = 177546
;TKS = 177560
;TKB = 177562
;TPS = 177564
;TPB = 177566
;Ascii0 = 60
;Dot = 56
;Enter1 = 15
;Enter2 = 12
;Minus = 55




. = torg + 60
.word receive
.word 200
. = torg + 100
.word clock
.word 300

. = torg + 3000
main:		
			mov pc, sp				;init stack
			tst -(sp) 				;init stack
			
			
			
			
		;print opening message:	
			mov #openMsg, -(sp)
			jsr pc, print
			tst (sp)
			
			mov #input, r0
			mov #input, r1
			add #62, r1				;adress of end of input			
			tst (sp)+
		;Before any game has begun:
		stage1:
			mov #0, @#177546
			mov #0, gameStat
			mov #0, enter?
			mov #0, moved?
			mov #newRow, (sp)
			jsr pc, print
			mov #101, @#177560	
			wait					;<-
			cmp enter?, #1			
			bne .-8					;->
			mov #0, enter?
			mov #100, @#177560	
			cmp gameStat, #1
			bne stage1
		newTurn:
			jsr pc, prBoard
			mov #0, clockCounter
			mov #0, timeUp
			cmp Player, #1
			bne chkB
				mov timeW, currPTime
				cmp roleW, #1
				bne comTurn
				beq waitH
		chkB:
			mov timeB, currPTime
			cmp roleB, #1
			bne waitC
			beq waitH
			
		comTurn:
			mov #-1, Steps			;just for C
			mov #SrcPos, -(sp)		;just for C
			mov #DstPos, -(sp)		;just for C
			mov #WinParam, -(sp)	;just for C
		waitC:
			;how to deal with input???
			mov SrcPos, finalSP
			mov DstPos, finalDP
			mov WinParam, finalWP
			mov #newRow, -(sp)
			jsr pc, print
			tst (sp)+
			mov #101, @#177560
			
			add #2, Steps
			jsr pc, getMaxWP
			mov #100, @#177560
			
			tst -(sp)
			mov #Board, -(sp)
			mov #1, -(sp)
			jsr pc, checkWin
			tst (sp)+
			tst (sp)+
			cmp (sp)+, #1
			bne .+6
			jsr pc, exeStop
			
			tst -(sp)
			mov #Board, -(sp)
			mov #2, -(sp)
			jsr pc, checkWin
			tst (sp)+
			tst (sp)+
			cmp (sp)+, #1
			bne .+6
			jsr pc, exeStop
			
			cmp gameStat, #1
			bne stage1
			cmp timeUp, #1
			bne waitC
			mov #Board, -(sp)
			jsr r5, movPiece
		finalSP: .word 0 
		finalDP: .word 0
			br .+4
		finalWP: .word 0
		mov finalSP, -(sp)
		mov finalDP, -(sp)
		jsr pc, leap
			jsr pc, printCTime
			tst (sp)+
			neg Player
			add #3, Player
			br newTurn


		
		waitH:
			;| - | board address | player | reg link |
			mov #101, @#177560
			mov #newRow, (sp)
			jsr pc, print
			wait						;<-	
			cmp enter?, #1			
			bne .-10					;->
			mov #100, @#177560
			mov #0, enter?
			
			cmp timeUp, #1
			beq endGame
			
			tst -(sp)
			mov #Board, -(sp)
			mov #1, -(sp)
			jsr pc, checkWin
			tst (sp)+
			tst (sp)+
			cmp (sp)+, #1
			bne .+6
			jsr pc, exeStop
			
			tst -(sp)
			mov #Board, -(sp)
			mov #2, -(sp)
			jsr pc, checkWin
			tst (sp)+
			tst (sp)+
			cmp (sp)+, #1
			bne .+6
			jsr pc, exeStop
			
			cmp gameStat, #1
			beq .+6						
			jmp stage1
			cmp moved?, #1
			bne waitH
			mov #0, moved?
			jmp newTurn
			
		endGame:
			mov #0, @#177546
			mov #0, gameStat
			mov #15, (sp)
			jsr pc, printChr
			mov #12, (sp)
			jsr pc, printChr
			jsr pc, printChr
			cmp Player, #1
			bne endgB
			mov #STstopW2, (sp)
			jsr pc, print
			mov #40, (sp)
			jsr pc, printChr
			mov #Computer, (sp)
			cmp roleW, #0
			beq endgNext
			mov #Human, (sp)
			br endgNext
		endgB:
			mov #STstopB2, (sp)
			jsr pc, print
			mov #40, (sp)
			jsr pc, printChr
			mov #Computer, (sp)
			cmp roleB, #0
			beq endgNext
			mov #Human, (sp)
			;br endgNext
		endgNext:
			jsr pc, print
			mov #endMsg, (sp)
			jsr pc, print
			jmp stage1
			
			
			

leap:		;checks if leap has occured and deletes center piece accordingly
			; STACK: | SrcPos | DstPos | PC |
			
			mov r1, -(sp)			; | r1 | PC | DstPos | SrcPos |
			mov 6(sp), r1			; mov srcPos to r1 and sub dstpos from it to find difference between those
			sub 4(sp), r1
			tst r1
			bpl .+4					;absolute value of difference
				neg r1
			cmp r1, #22
			ble return3
				mov 6(sp), r1
				add 4(sp), r1
				asr r1
				mov #0, Board(r1)
	return3:
			mov (sp)+, r1
			rts pc
			

receive: 	;receives input~
			;assumes r0 points to current pos in input, and r1 to input's end
			
			tstb @#177560
			bpl .-4
			clr -(sp)					; 0 |
			movb @#177562, (sp)			;char |
			
			cmp (sp), #15				;is enter?
			bne r_check2
				mov #1, enter?
				mov #15, (sp)			;'\r'
				jsr pc, printChr
				mov #12, (sp)			;'\n'
				jsr pc, printChr
				jsr pc, printChr		;go down *2* rows
				mov #input, r0
				;
				jsr pc, readCmd
				jsr pc, clrInput
				br r_end
				
	r_check2:
			cmp (sp), #10				;is BackSpace?
			bne r_next					;->	
				cmp r0, #input
				ble r_end
				jsr pc, printChr		;char(which is BS) |
				mov #40, (sp)			; - |
				jsr pc, printChr				
				mov #10, (sp)			;BS |
				jsr pc, printChr
				tstb -(r0)
				clrb (r0)
				br r_end
	r_next:	cmp r0, r1
			bge r_end
			movb @#177562, (r0)+			;<-
			jsr pc, printChr
	r_end:	tst (sp)+					;~empty~
			bis #1, @#177560
			rti

print:	;Receives in stack (top to bottom):			
										;<text> | ...
										;pc | <text> | ...
			mov r0, -(sp)				;r0 | pc | <text> | ...
			mov 4(sp), r0				;r0 now holds the adress to the text
		;wait until printer is free:
	p_next1:		
			cmpb (r0), #0
			beq p_next2
		;wait for printer:
			tstb @#177564								
			bpl .-4
		;then:
			movb (r0)+, @#177566
			br p_next1
	p_next2:		
			mov (sp)+, r0				; pc | <text> | ...
			rts pc


printChr:;Receives in stack (top to bottom):			
										; char | ...
										;pc | char | ...
		;wait until printer is free:
			tstb @#177564								
			bpl .-4
		;then:
			movb 2(sp), @#177566
			rts pc

printCTime:			;prints line:	[player] computer move took [T] seconds.	
					;used after computer makes move
					;input: time to make move in clockCounter label
					;		player in common area
					
			cmp Player, #1				;if player is 1 print word White, otherwise print Black
			beq .+10
				mov #STstopB2, -(sp)	; | pc | <text> |
				br .+6
			mov #STstopW2, -(sp)		; | pc | <text> |
			jsr pc, print				;prints [player]
			mov #comMove, (sp)			; | pc | <text> |
			jsr pc, print				; prints (computer move took )
			mov r1, (sp)				; | pc | r1 |
			mov clockCounter, r1		;prepare for printTime function
			jsr pc, printTime			; prints [T]
			mov (sp), r1
			mov #STmove2, (sp)			; | pc | <text> |
			jsr pc, print				; prints (seconds)
			mov #56, (sp)				; | pc | #56 |
			jsr pc, printChr			; prints (.) (dot)
			mov #15, (sp)				; | pc | enter (part 1) |
			jsr pc, printChr
			mov #12, (sp)				; | pc | enter (part 2) |
			jsr pc, printChr
			tst (sp)+
			rts pc
			
			
			
			
			
clrInput:	;sets
			mov r0, -(sp)
			mov #input, r0
			mov r1, -(sp)
			mov #62, r1					;62 (50 decimal) is maximum input length
			clrb (r0)+ 					;maybe put space instead?
			sob r1, .-2
			mov (sp)+, r1
			mov (sp)+, r0
			rts pc
			
startChk:	;receives empty place in stack, to flag whether executed or not
			;r0 used for iterating over input
			;r1 used for calculating time
			mov #0, 2(sp)				;pc | 0 | ...	- the flag for whether exe'd or not
			mov r0, -(sp)				;r0 | pc | 0 | ...
			mov #input, r0
			mov r1, -(sp)				;r1 | r0 | pc | 0 | ...
			clr r1
			mov r2, -(sp)				;r2 | r1 | r0 | pc | 0 | ...
			
			tstb -(r0)					
			tstb (r0)+					;<-
			cmpb (r0), #40 				;' '
			beq .-6						;-> 
			
			cmpb (r0)+, #163			;'s'
			bne .+6						; supposed to be sChkX but branch too far
			cmpb (r0)+, #164			;'t'
			bne sChkX
			cmpb (r0)+, #141			;'a'
			bne sChkX
			cmpb (r0)+, #162			;'r'
			bne sChkX
			cmpb (r0)+, #164			;'t'
			bne sChkX
			cmpb (r0), #40				;' '
			bne sChkX
						
			tstb (r0)+					;<-
			cmpb (r0), #40 				;' '
			beq .-6						;-> 
			
			cmpb (r0), #143				;'c'
			bne sChk1
				mov #0, RtempW
				br sChk2				
		sChk1:	
			cmpb (r0), #150				;'h'
			bne sChkX
				mov #1, RtempW
				;br sChk2
				
		sChk2:
			tstb (r0)+
			cmpb (r0), #40				;' '
			bne sChkX
		
			tstb (r0)+					;<-
			cmpb (r0), #40 				;' '
			beq .-6						;->
			
			clr -(sp)					; *0* | r1 | r0 | pc | 0 | ...
			mov #secondsW, r2
		exe1num1:
			movb (r0), (r2)+
			movb (r0)+, (sp)			;char | r1 | r0 | pc | 0 | ...
			jsr pc, trnToNum			;*num* | r1 | r0 | pc | 0 | ...
			cmp (sp), #-1
			bne sChk3
				clrb -(r2)
				tst (sp)+					;r1 | r0 | pc | 0 | ...
				br sChkX			
		sChk3:
			mul #12, r1
			add (sp), r1
			
			cmpb (r0), #40				;' '
			bne exe1num1
			mov r1, TtempW
			movb #0, (r2) 				;puts an end in seconds, for print
			tst (sp)+					;r1 | r0 | pc | 0 | ...
			
			tstb (r0)+					;<-
			cmpb (r0), #40 				;' '
			beq .-6						;-> 
			
			cmpb (r0), #143				;'c'
			bne sChk4
				mov #0, RtempB
				br sChk5				
		sChk4:	
			cmpb (r0), #150				;'h'
			bne sChkX
				mov #1, RtempB
				;br sChk5
				
		sChk5:
			tstb (r0)+
			cmpb (r0), #40				;' '
			bne sChkX
		
			tstb (r0)+					;<-
			cmpb (r0), #40 				;' '
			beq .-6						;->
			
			clr r1
			tst -(sp)					; - | r1 | r0 | pc | 0 | ...
			clr (sp)					;0 | r1 | r0 | pc | 0 | ...
			mov #secondsB, r2
		exe1num2:	
			movb (r0), (r2)+
			movb (r0)+, (sp)			;char | r1 | r0 | pc | 0 | ... 
			jsr pc, trnToNum			;*num* | r1 | r0 | pc | 0 | ...
			cmp (sp), #-1
			bne sChk6
				clrb -(r2)
				tst (sp)+					;r1 | r0 | pc | 0 | ...
				br sChkX			
		sChk6:
			mul #12, r1
			add (sp), r1
			
			cmpb (r0), #0				;'\0'
			beq exe1exe
			cmpb (r0), #40				;' '
			beq exe1exe
			br exe1num2
			
		sChkX:
			mov (sp)+, r2					;r1 | r0 | pc | 0 | ...
			mov (sp)+, r1					;r0 | pc | 0 | ...
			mov (sp)+, r0					;pc | 0 | ...
			;mov #0, 2(sp)
			rts pc
					
		exe1exe:
			movb #0, (r2)					;puts an end in seconds, for print
			mov r1, TtempB
			tst (sp)+						;r2 | r1 | r0 | pc | 0 | ...
			
			mov RtempW, roleW
			mov TtempW, r1
			mul rate, r1
			mov r1, timeW
			mov RtempB, roleB
			mov TtempB, r1
			mul rate, r1
			mov r1, timeB
			jsr pc, exeStart
			mov (sp)+, r2					;r1 | r0 | pc | 0 | ...
			mov (sp)+, r1					;r0 | pc | 0 | ...
			mov (sp)+, r0					;pc | 0 | ...
			mov #1, 2(sp)
			rts pc		
RtempW: .blkw 1
TtempW: .blkw 1
RtempB: .blkw 1
TtempB: .blkw 1

			
exeStart:
			mov #100, @#177546
			mov #1, Player
			mov #1, Steps
			mov #1, gameStat
			mov #startMsg, -(sp)
			jsr pc, print
			mov #startM_W, (sp)
			jsr pc, print
			mov #Computer, (sp)
			cmp roleW, #0
			beq exsNext1
			mov #Human, (sp)
		exsNext1:
			jsr pc, print
			mov #with, (sp)
			jsr pc, print
			mov #secondsW, (sp)
			jsr pc, print
			mov #startM2, (sp)
			jsr pc, print
			
			mov #startM_B, (sp)
			jsr pc, print
			mov #Computer, (sp)
			cmp roleB, #0
			beq exsNext2
			mov #Human, (sp)
		exsNext2:
			jsr pc, print
			mov #with, (sp)
			jsr pc, print
			mov #secondsB, (sp)
			jsr pc, print
			mov #startM2, (sp)
			jsr pc, print
			tst (sp)+
			jsr pc, stBoard
			rts pc
			
trnToNum:	;gets in stack a number that represents an ascii code
			;*overwrites it* and returns the (oct)number it represents
			;if it's not a digit at all, returns -1
										;pc | digit
			cmp 2(sp), #60
			blt ttnBad
			cmp 2(sp), #71
			bgt ttnBad
			sub #60, 2(sp)				;pc | actualNum
			rts pc	
		ttnBad:
			mov #-1, 2(sp)				;pc | -1
			rts pc
			
;reads the input and calls the appropriate command, if game status permits
readCmd:	
			tst -(sp)						; - | pc
			cmp gameStat, #1
			beq rcmd1
			jsr pc, startChk
			cmp (sp), #1
			beq rcmdX
			br rcmdErr
			
		rcmd1:
			jsr pc, stopChk
			cmp (sp), #1
			beq rcmdX
			jsr pc, timeChk
			cmp (sp), #1
			beq rcmdX
			cmp Player, #1
			bgt	rcmd2
				cmp roleW, #1
				beq rcmd3
					br rcmdErr
		rcmd2:
				cmp roleB, #1
				beq rcmd3
					br rcmdErr
			
		rcmd3:
			jsr pc, moveChk
			mov (sp), moved?
			cmp (sp), #1
			beq rcmdX
			;br rcmdErr
			
		rcmdErr:
			mov #cntExe1, -(sp)				;<cantExecute1> | 0 | pc | ...
			jsr pc, print
			mov #input, (sp)				;<input> | 0 | pc | ...
			jsr pc, print
			mov #cntExe2, (sp)				;<cantExecute2> | 0 | pc | ...
			jsr pc, print			
			tst (sp)+
		rcmdX:
			tst (sp)+
			rts pc
			
stopChk: 
		mov #0, 2(sp)
		mov r0, -(sp)
		mov #input, r0
		
		cmpb (r0)+, #163			;'s'
		bne stpChkX
		cmpb (r0)+, #164			;'t'
		bne stpChkX
		cmpb (r0)+, #157			;'o'
		bne stpChkX
		cmpb (r0)+, #160			;'p'
		bne stpChkX
		cmpb (r0), #0				;'\0'
		beq stpChk1
		cmpb (r0), #40				;' '
		beq stpChk1
	stpChkX:
		mov (sp)+, r0
		rts pc
	
	stpChk1:
		mov #1, 4(sp)
		jsr pc, exeStop
		br stpChkX
		
		
exeStop:		;stops shit.	
				mov r0, -(sp)							; | r0 | pc |... 
				mov r1, -(sp)							; | r1 | r0 | pc |...
				mov r4, -(sp)							; | r4 | r1 | r0 | pc |...
				mov #15, -(sp)						; | char | r4 | r1 | r0 | pc |
				jsr pc, printChr
				mov #12, (sp)						; | char | r4 | r1 | r0 | pc |
				jsr pc, printChr
				mov #STstop1, (sp)						; | text address | r4 | r1 | r0 | pc |
				jsr pc, print
				
				cmp #1, Player
				beq .+14
					mov #STstopB1, (sp)
					jsr pc, print
					br .+12
				mov #STstopW1, (sp)
				jsr pc, print
				
				mov #STstop2, (sp)
				jsr pc, print
				mov #Board, (sp)						; | #Board | r4 | r1 | r0 | pc |
				mov Player, -(sp)						; | Player | #Board | r4 | r1 | r0 | pc |
				jsr pc, calcWP
				tst (sp)+	 							; | #Board | r4 | r1 | r0 | pc |
				tst (sp)+								; | r4 | r1 | r0 | pc |
				mov r4, r1								; r4 holds the result from calcWP
				mov r4, -(sp)							; | WP | r4 | r1 | r0 | pc |
				mov #1, r4								; r4 now holds how many digits are in the WP result
				
				tst r1									
				bpl .+16
					mov #55, -(sp)						;'-'
					jsr pc, printChr
					tst (sp)+
					neg r1
				
				cmp r1, #10
				blt .+26
					tst r1
					sxt r0
					div #10, r0
					inc r4
					add #60, r1							;'0'					
					mov r1, -(sp)						; | | | | | | <- WP digits | WP | r4 | r1 | r0 | pc |
					mov r0, r1
					br .-30
				add #60, r1
				mov r1, -(sp)							; | last digit | | | | | | <- WP digits | WP | r4 | r1 | r0 | pc |
				jsr pc, printChr
				tst(sp)+
				sob r4, .-6
				
				; | WP | r4 | r1 | r0 | pc |
				
				mov #15, -(sp)
				jsr pc, printChr
				mov #12, (sp)
				jsr pc, printChr			
				mov #15, (sp)
				jsr pc, printChr
				mov #12, (sp)
				jsr pc, printChr
				mov Player, r0
				tst (sp)+
				tst (sp)								;check if WP is positive
				beq printTie
				bpl .+10
					neg r0
					add #3, r0
				cmp r0, #2
				beq .+14
					mov #STstopW2, (sp)
					jsr pc, print
					br .+12
				mov #STstopB2, (sp)
				jsr pc, print
				
				mov #STstop3, (sp)
				jsr pc, print
				
				tst (sp)+								; | r4 | r1 | r0 | pc |
				mov (sp)+, r4							; | r1 | r0 | pc |
				mov (sp)+, r1							; | r0 | pc |
				mov (sp)+, r0							; | pc |
				mov #0, gameStat
				
				rts pc
				
	printTie:	mov #STtie, (sp)
				jsr pc, print
				
				tst (sp)+								; | r4 | r1 | r0 | pc |
				mov (sp)+, r4							; | r1 | r0 | pc |
				mov (sp)+, r1							; | r0 | pc |
				mov (sp)+, r0							; | pc |
				mov #0, gameStat
				
				rts pc
				
				
		
timeChk: 
		mov #0, 2(sp)
		mov r0, -(sp)
		mov #input, r0
		
		cmpb (r0)+, #164			;'t'
		bne tChkX
		cmpb (r0)+, #151			;'i'
		bne tChkX
		cmpb (r0)+, #155			;'m'
		bne tChkX
		cmpb (r0)+, #145			;'e'
		bne tChkX
		cmpb (r0), #0				;'\0'
		beq tChk1
		cmpb (r0), #40				;' '
		beq tChk1
	tChkX:
		mov (sp)+, r0
		rts pc
	
	tChk1:
		mov #1, 4(sp)
		jsr pc, exeTime
		br tChkX
		
exeTime:		mov r1, -(sp)							; | r1 | pc |
				mov #STtime1, -(sp)						; | string | r1 | pc |
				jsr pc, print								
				cmp #1,  timeUp
				beq noTime
				
					mov currPTime, r1
					sub clockCounter, r1
					jsr pc, printTime
					
					
	string2:		mov #STtime2, (sp)						; | string | r1 | pc |
					jsr pc, print
					mov #15, (sp)
					jsr pc, printChr
					mov #12, (sp)
					jsr pc, printChr
					tst (sp)+								; | r1 | pc |
					mov (sp)+, r1							; | pc |
					
					rts	pc		

					
	noTime:		mov #STtime3, (sp)
				mov #3, -(sp)
				jsr pc, print
				tst (sp)+
				br string2
				
				
movPiece:
										;| STACK: #Board, reg link (r5)
										;input:	SourcePosition - inline (r5++)
										;		DestinPosition - inline (r5+2)
										
			mov r0, -(sp)				;| #Board | reg link | r0 |
			mov 4(sp), r0				;asign Board address to r0 
			mov r1, -(sp)				;| #Board | reg link | r0 | r1 |
			mov (r5)+, r1				;assign SrcPos to r1
			mov r2, -(sp)				;| #Board | reg link | r0 | r1 | r2 |
			mov r3, -(sp)				;| #Board | reg link | r0 | r1 | r2 | r3 |
			mov (r5)+, r2				;assign DstPos to r2
			add r0, r1					;add boardPos to SrcPos in order to get the actual adress
			add r0, r2					;add boardPos to DstPos in order to get the actual adress 
			
			mov (r1), r3				;save player in SrcPos
			mov #0, (r1)				;assign 0 to SrcPos
			mov r3, (r2)				;assign player in SrcPos to DstPos
			mov (sp)+, r3				;| #Board | reg link | r0 | r1 | r2 |
			mov (sp)+, r2				;| #Board | reg link | r0 | r1 |
			mov (sp)+, r1				;| #Board | reg link | r0 |
			mov (sp)+, r0				;| #Board | reg link |
			
			rts r5			
				
			
moveChk: 
		mov #0, 2(sp)				;pc | 0
		mov r0, -(sp)				;r0 | pc | 0
		mov #input, r0
		mov r1, -(sp)				;r1 | r0 | pc | 0 |...
		
		cmpb (r0)+, #155			;'m'
		bne mChkX
		cmpb (r0)+, #157			;'o'
		bne mChkX
		cmpb (r0)+, #166			;'v'
		bne mChkX
		cmpb (r0)+, #145			;'e'
		bne mChkX
		cmpb (r0), #40				;' '
		bne mChkX
		;skip spaces:
		tstb (r0)+					;<-
		cmpb (r0), #40 				;' '
		beq .-6						;->
		
		clr -(sp)					; - | r1 | r0 | pc | 0 |...
		movb (r0)+, (sp)			;char | r1 | r0 | pc | 0 |...
		jsr pc, trnToNum			;*num* | r1 | r0 | pc | 0 |...
		mov (sp)+, r1				;r1 | r0 | pc | 0 |...
		cmp r1, #-1
		beq mChkX
		cmp r1, #10					;means the digit is 8 or 9, which is invalid
		bge mChkX
		asl r1						;multiply by 8, and then by 2:
		asl r1
		asl r1
		asl r1						;by 2
		add r1, tempSrc
		
		clr -(sp)					; - | r1 | r0 | pc | 0 |...
		movb (r0)+, (sp)			;char | r1 | r0 | pc | 0 |...
		jsr pc, trnToNum			;*num* | r1 | r0 | pc | 0 |...
		mov (sp)+, r1				;r1 | r0 | pc | 0 |...
		cmp r1, #-1
		beq mChkX
		cmp r1, #10					;means the digit is 8 or 9, which is invalid
		bge mChkX
		asl r1						;by 2
		add r1, tempSrc
		
		cmpb (r0), #40				;' '
		bne mChkX
		tstb (r0)+					;<-
		cmpb (r0), #40 				;' '
		beq .-6						;->
				
		clr -(sp)					; - | r0
		movb (r0)+, (sp)			;char | r0
		jsr pc, trnToNum			;*num* | r0
		mov (sp)+, r1				;r0
		cmp r1, #-1
		beq mChkX
		cmp r1, #10					;means the digit is 8 or 9, which is invalid
		bge mChkX
		asl r1						;multiply by 8, and then by 2 (because each word is 2 bytes):
		asl r1
		asl r1
		asl r1						
		add r1, tempDst
		
		clr -(sp)					; - | r1 | r0 | pc | 0 |...
		movb (r0)+, (sp)			;char | r1 | r0 | pc | 0 |...
		jsr pc, trnToNum			;*num* | r1 | r0 | pc | 0 |...
		mov (sp)+, r1				;r1 | r0 | pc | 0 |...
		cmp r1, #-1
		beq mChkX
		cmp r1, #10					;means the digit is 8 or 9, which is invalid
		bge mChkX
		asl r1						;multiply by 2 (because each word is 2 bytes):
		add r1, tempDst
				
		cmpb (r0), #0				;'\0'
		beq mChk1
		cmpb (r0), #40				;' '
		beq mChk1
	mChkX:
		clr tempSrc
		clr tempDst
		mov (sp)+, r1				;r0 | pc | -
		mov (sp)+, r0				;pc | -
		rts pc
	
	mChk1:
		mov tempSrc, SrcPos
		mov tempDst, DstPos
		tst -(sp)					; - | r1 | r0 | pc | 0 |...
		jsr pc, exeMove				;0/1 | r1 | r0 | pc | 0 |...
		cmp (sp), #1
		bne .+10 					;->
		mov #1, 10(sp)
		tst (sp)+					;<- ;r1 | r0 | pc | 0 |...
		br mChkX					
tempSrc: .blkw 1
tempDst: .blkw 1




stBoard:	;restarts the board
			mov r0, -(sp)
			mov r1, -(sp)
			mov r2, -(sp)
			
			mov #Board, r0
			mov #BoardSt, r1
			mov #100, r2
			;<-
			mov (r1)+, (r0)+
			sob r2, .-2			;or -10? 
			;->
			mov (sp)+, r2
			mov (sp)+, r1
			mov (sp)+, r0
			rts pc





exeMove:		mov r2, -(sp)							; | r2 | pc | - |
				mov r4, -(sp)							; | r4 | r2 | pc | - |
				mov r5, -(sp)							; | r5 | r4 | r2 | pc | - |
				mov clockCounter, 10(sp)				; | r5 | r4 | r2 | pc | time |
				mov Player, r2
				dec r2
				asl r2
				asl r2
				tst roleW(r2)
				beq ilegal
				
				; if player is human continue with interrupt function
				tst SrcPos
				bmi ilegal
				cmp SrcPos, #176
				bgt ilegal
				tst DstPos
				bmi ilegal
				cmp SrcPos, #176 
				bgt ilegal
				
				mov SrcPos, r4
				add #Board, r4
				cmp (r4), Player
				bne illegal
				
				cmp SrcPos, DstPos						;check if the player which doesnt make a move, has no moves
				bne .+32
					tst -(sp)							; | - | r5 | r4 | r2 | pc | time |
					mov #Board, -(sp)					; | #Board | - | r5 | r4 | r2 | pc | time |
					mov Player, -(sp)					; | Player | #Board | - | r5 | r4 | r2 | pc | time |
					jsr pc, cntMoves
					tst (sp)+							; | #Board | Num_moves | r5 | r4 | r2 | pc | time |
					tst (sp)+							; | Num_moves | r5 | r4 | r2 | pc | time |
					tst (sp)+							; | r5 | r4 | r2 | pc | time |
					beq finish
						br illegal
				
				mov DstPos, r4
				add #Board, r4	
				cmp (r4), #0
				bne illegal
			
				


				
				mov SrcPos, r5							;find placement on the X axis of board
				clr r4									;for later usage
				div #20, r4								;
				
				mov SrcPos, r2
				sub DstPos, r2
				
				cmp Player, #2
				beq BChkLegal

	;else
	;WChkLegal:		
				tst r2
				bmi illegal
				
				cmp r2, #22
				bgt WChkLeap
					cmp r5, #16						;check if on right edge
					bne .+12
						cmp r2, #22					;check if move is exactly diagonally left upwards
						bne illegal
							br finish
						
					cmp r5, #0						;check if on the left edge
					bne .+12
						cmp r2, #16					;check if move is exactly diagonally right upwards
						bne illegal
							br finish
					cmp r2, #16
					beq finish
						cmp r2, #22
						beq finish
							br illegal
					
	ilegal:		br illegal

					
	WChkLeap:	cmp r5, #2
				bgt .+12
					cmp r2, #34
					bne illegal
						br finishL
				
				cmp r5, #14
				blt	.+12
					cmp r2, #44
					bne illegal
						br finishL
				
				cmp r2, #34
				beq finishL
					cmp r2, #44
					beq finishL
						br illegal
						
	BChkLegal:	tst r2
				bpl illegal
				
				neg r2
				cmp r2, #22
				bgt BChkLeap
					cmp r5, #16						;check if on right edge
					bne .+12
						cmp r2, #16					;check if move is exactly diagonally left downward
						bne illegal
							br finish
						
					cmp r5, #0						;check if on the left edge
					bne .+12
						cmp r2, #22					;check if move is exactly diagonally right downward
						bne illegal
							br finish
					cmp r2, #16
					beq finish
						cmp r2, #22
						beq finish
							br illegal
						


	finishL:	mov DstPos, r5
				add SrcPos, r5
				asr r5
				add #Board, r5
				mov #0, (r5)
				
				br finish
				
	illegal:		
				mov Player, r2
				neg r2
				add #3, r2
				mov r2, Player
				mov #0, 10(sp)							; | r5 | r4 | r2 | pc | 0 |
				mov (sp)+, r5							; | r4 | r2 | pc | 0 |	
				mov (sp)+, r4							; | r2 | pc | 0 |	
				mov (sp)+, r2							; | pc | 0 |
				rts pc
				
						
						
	finish:		mov #Board, -(sp)						; | #Board | r5 | r4 | r2 | pc | time |
				mov SrcPos, .+20
				mov DstPos, .+14
				jsr r5, movPiece
				.blkw 2
				mov #STstopB2, (sp)					; | String | r5 | r4 | r2 | pc | time |
				cmp Player, #2
				beq .+6
					mov #STstopW2, (sp)
				jsr pc, print
				mov #STmove1, (sp)
				jsr pc, print
				mov 12(sp), r1
				jsr pc, printTime
				mov #STmove2, (sp)
				jsr pc, print
				mov #15, (sp)
				jsr pc, printChr
				mov #12, (sp)
				jsr pc, printChr
				mov Player, r2
				neg r2
				add #3, r2
				mov r2, Player
				tst (sp)+								; | r5 | r4 | r2 | pc | time |
				mov #1, 10(sp)							; | r5 | r4 | r2 | pc | 1 |
				mov (sp)+, r5							; | r4 | r2 | pc | 1 |	
				mov (sp)+, r4							; | r2 | pc | 1 |	
				mov (sp)+, r2							; | pc | 1 |
				rts pc

							
	BChkLeap:	cmp r5, #2
				bgt .+12
					cmp r2, #44
					bne illegal
						br finishL
				
				cmp r5, #14
				blt	.+12
					cmp r2, #34
					bne illegal
						br finishL
				
				cmp r2, #34
				beq finishL
					cmp r2, #44
					beq finishL
						br illegal
						
						
						
						
printTime:		mov r0, -(sp)							; | r0 | pc |
				mov r2, -(sp)							; | r2 | r0 | pc |
				mov #1, r2								; used to count digits of time passed, set to 1 to prevent endless sob loop
				clr r0
				div rate, r0
				mov r1, -(sp)							; | reminder of rate | r2 | r0 | pc |
				
				cmp r0, #10.							;see if time is less than 10 seconds, otherwise seperate it to it's different 10's components
				blo .+24
					inc r2								;counts the digits so unpacking them from stack would be easier
					mov r0, r1
					clr r0
					div #10., r0
					add #60, r1
					mov r1, -(sp)						; | | | | | | | <- Digits of time in ascii | remainder | r2 | r0 | pc |
					br .-26								;continue with breaking the number to its digits
					
				add #60, r0
				mov r0, -(sp)							; | first digit of time | | | | | remainder | r2 | r0 | pc |

														; < -
				jsr	pc, printChr						; - >
				tst (sp)+
				sob r2, .-6								; < -
				
				mov #56, -(sp)							; | "." | remainder | r2 | r0 | pc |
				jsr pc, printChr
				tst (sp)+								; | remainder | r2 | r0 | pc |
				mov (sp), r1
				mul #10., r1
				clr r0
				div rate, r0
				add #60, r0
				mov r0, (sp)							; | the tenth of time | r2 | r0 | pc |
				jsr pc, printChr
				tst (sp)+								; | r2 | r0 | pc |
				mov (sp)+, r2							; | r0 | pc |
				mov (sp)+, r0							; | pc |
				rts pc
				
						
clock:			inc clockCounter
				cmp currPTime, clockCounter
				blo .+4
					rti
				mov #1, timeUp
				mov #1, enter?
				rti
				
				
prBoard:		;prints the board.
				;r0 iterates over the board
				;r1 is the counts the tiles per row
				;r2 counts the rows
				mov r0, -(sp)
				mov r1, -(sp)
				mov r2, -(sp)
				mov #boardLO, -(sp)
				jsr pc, print
				mov #Board, r0
				mov #10, r1
				mov #10, r2
			prbLoop:
				cmp (r0), #0
				bne prbNext1
					mov #137, (sp)						;'_'
					jsr pc, printChr
					br prbNext3
			prbNext1:
				cmp (r0), #1							
				bne prbNext2
					mov #127, (sp)						;'W'
					jsr pc, printChr
					br prbNext3
			prbNext2:
				cmp (r0), #2
				bne prbNext3
					mov #102, (sp)						;'B'
					jsr pc, printChr
					;br prbNext3
			prbNext3:
				tst (r0)+
				sob r1, prbLoop
				mov #15, (sp)							;'\r'
				jsr pc, printChr
				mov #12, (sp)							;'\n'
				jsr pc, printChr
				mov #10, r1
				sob r2, prbLoop
				
				jsr pc, printChr
				mov #curP_msg, (sp)
				jsr pc, print
				cmp Player, #1
				bne prbNextB
			;prbNextW:
				mov #STstopW2, (sp)
				jsr pc, print
				mov #40, (sp)
				jsr pc, printChr
				mov #Computer, (sp)
				cmp roleW, #1
				bne .+6
				mov #Human, (sp)
				jsr pc, print
				br prbNext5
				
			prbNextB:
				mov #STstopB2, (sp)
				jsr pc, print
				mov #40, (sp)
				jsr pc, printChr
				mov #Computer, (sp)
				cmp roleB, #1
				bne .+6
				mov #Human, (sp)
				jsr pc, print
				;br prbNext5
				
				
			prbNext5:
				mov #15, (sp)
				jsr pc, printChr
				mov #12, (sp)
				jsr pc, printChr
				tst (sp)+
				mov (sp)+, r2
				mov (sp)+, r1
				mov (sp)+, r0
				rts pc
					
				




				

;~~~~~from here on it's ATAM3:~~~~~


			
;checks if player has any playpieces on board, if not that is not a winning situation
checkWin:								;| - | board address | player | reg link |
			mov r0, -(sp)				;preservation of registers, now used to hold current players
										;| - | board address | player | reg link | r0 |

		;we pass parameters for the next function
		
			tst -(sp)					;| - | board address | player | reg link | r0 | - |
			mov 8(sp), -(sp)			;| - | board address | player | reg link | r0 | - | board address |
			mov 8(sp), -(sp)			;| - | board address | player | reg link | r0 | - | board address | player |
			jsr pc, cntPlay				;| - | board address | player | reg link | r0 | number of player pieces | board address | player |
			mov 4(sp), PlayCnt			
			bne countP2					;if PlayCnt is 0 we know for sure hasn't won
				br PLYnoWIN

		;checks if *Adversary* has any playpieces on board, if not player has won
			
	countP2:
			mov #3,r0					;used to get the number of the other player
			sub 12(sp),r0				;
			mov r0, (sp)				;| - | board address | player | reg link | r0 | number of player pieces | board address | *Adversary* |
			jsr pc, cntPlay				;| - | board address | player | reg link | r0 | number of *Adversary* pieces | board address | *Adversary* |
			mov 4(sp), OppCnt
			bne movesP1					;if *Adversary* play piece count is 0, player has won
				br playWin

		;checks if player has any moves to make.
			
	movesP1:
			mov 12(sp), (sp)			;| - | board address | player | reg link | r0 | number of *Adversary* pieces | board address | player |
			jsr pc, cntMoves			;| - | board address | player | reg link | r0 | player possible moves | board address | player |
			tst 4(sp)					;check if has more than 0 moves for player
			beq movesP2
				br PLYnoWIN

		;checks if *Adversary* has any moves to make. if both players can't move count difference between playpiece number
	
	movesP2:
			mov r0, (sp)				;| - | board address | player | reg link | r0 | player possible moves | board address | *Adversary* |
			jsr pc, cntMoves			;| - | board address | player | reg link | r0 | *Adversary* possible moves | board address | *Adversary* |
			tst 4(sp)					;check if has more than 0 moves for *Adversary*
			beq findDiff
				br PLYnoWIN
			
		;finds who wins by checking who has more pieces on board		
			
	findDiff:	
			cmp PlayCnt, OppCnt			;if no moves left and player has more piece announce win
			bgt playWin
				br PLYnoWIN
			
		;unwraps routines and empties stack, win flag is up
			
	playWin:	
			add #6, sp					;| - | board address | player | reg link | r0 |
			mov (sp)+, r0				;| - | board address | player | reg link |
			mov #1, 6(sp)				;| 1 | board address | player | reg link |
			rts pc
			
		;unwraps routines and empties stack, no known win flag is up
			
	PLYnoWIN:
			add #6, sp					;| - | board address | player | reg link | r0 |
			mov (sp)+, r0				;| - | board address | player | reg link |
			mov #-1, 6(sp)				;| -1 | board address | player | reg link |
			rts pc

PlayCnt:	.blkw 1
OppCnt:		.blkw 1





			
			
gwpaPrep:								;STACK:  tempWP, #Board, #Player, steps, curPlayer, pc, srcIndex, - , dstIndex, pc2, pc3
			;getting ready for makeMov:
			mov #0, 6(sp)
			mov r4, -(sp)				;STACK:  tempWP, #Board, #Player, steps, curPlayer, pc, srcIndex, - , dstIndex, pc2, pc3, ^r4
			mov r5, -(sp)				;STACK:  tempWP, #Board, #Player, steps, curPlayer, pc, srcIndex, - , dstIndex, pc2, pc3, ^r4, ^r5
			mov 14(sp), r4				
			mov 10(sp),  r5
			mov 26(sp), -(sp)			;STACK: ..., #Board
			mov 26(sp), -(sp)			;STACK: ..., #Board, #Player
			mov 26(sp), -(sp)			;STACK: ..., #Board, #Player, Steps
			mov 36(sp), -(sp)			;STACK: ..., #Board, #Player, Steps, tempWP
			mov 30(sp), -(sp)			;STACK: ..., #Board, #Player, Steps, tempWP, curPlayer
			cmp #1, timeUp
			beq packRec1				;if time is up return to last function
				jsr pc, makeMov				;STACK: ..., #Board, #Player, Steps, newWP, curPlayer
				mov 2(sp), 42(sp)			;assign new WP
				add #12, sp					;STACK:  tempWP, #Board, #Player, steps, curPlayer, pc, srcIndex, - , dstIndex, pc2, pc3, ^r4, ^r5
				mov (sp)+, r5				;STACK:  tempWP, #Board, #Player, steps, curPlayer, pc, srcIndex, - , dstIndex, pc2, pc3, ^r4
				mov (sp)+, r4				;STACK:  tempWP, #Board, #Player, steps, curPlayer, pc, srcIndex, - , dstIndex, pc2, pc3
				rts pc
				
		packRec1:
			mov #1, stepInvalid
			mov #Player, -(sp)			;STACK: ..., #Board, #Player, Steps, tempWP, curPlayer, #Player
			jsr pc, minOrMax
			add #14, sp					;STACK:  tempWP, #Board, #Player, steps, curPlayer, pc, srcIndex, - , dstIndex, pc2, pc3, ^r4, ^r5
			mov #21, 30(sp)		;STACK:  H, #Board, #Player, steps, curPlayer, pc, srcIndex, - , dstIndex, pc2, pc3, ^r4, ^r5
			tst r4
			bmi .+10				;if looking for minimum return highest score and vice versa, so worst output will be returned for 
										;recursion run
				mov #177757, 30(sp)			;STACK:  L, #Board, #Player, steps, curPlayer, pc, srcIndex, - , dstIndex, pc2, pc3, ^r4, ^r5
		packRec2:
			mov (sp)+, r5				;STACK:  H\L, #Board, #Player, steps, curPlayer, pc, srcIndex, - , dstIndex, pc2, pc3, ^r4
			mov (sp)+, r4				;STACK:  H\L, #Board, #Player, steps, curPlayer, pc, srcIndex, - , dstIndex, pc2, pc3
			mov #1, 6(sp)
			rts pc
			
			
gwpBlack: 								;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, - , - , - , pc2
			mov #-2, 6(sp) 				;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, -2, - , -, pc2
		gwpLoopB:		
			add #2, 6(sp)				;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, - , -, pc2
			cmp 6(sp), #160
			blt gwpBnxt1				;if reached end of board, stops
				rts pc
		gwpBnxt1:
			mov 6(sp), 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, - , index, pc2
			add #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, - , #Board+index, pc2
			cmp @2(sp), #2			;checks if tile has black
			bne gwpLoopB				;if not, check next tile
			
			sub #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, - , index, pc2
			jsr pc, isOnLeft			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result*, index, pc2
			cmp 4(sp), #1				;checks if on left border
			beq gwpRB					;if it is, check right move
			
			add #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result*, #Board+index, pc2
			add #16, 2(sp)				;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result*, #Board+stepIndex, pc2
			cmp @2(sp), #1				;check who's on move tile
			bgt gwpRB 					;if contains black, check right move 
			blt gwpBnxt2				;if empty, continue to recursion
			
			sub #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result*, stepIndex, pc2
			jsr pc, isOnBtm				;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result2*, stepIndex, pc2
			cmp 4(sp), #1				;checks if left move tile is on bottom side
			beq gwpRB					;if it is, check right move
			
			jsr pc, isOnLeft			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result3*, stepIndex, pc2
			cmp 4(sp), #1				;checks if left move tile is on left side
			beq gwpRB					;if it is, check right move
			
			add #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result3*, #Board+stepIndex, pc2
			add #16, 2(sp)				;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result3*, #Board+LEAPIndex, pc2
			cmp @2(sp), #0			;checks if left LEAP tile is 0 or not
			bne gwpRB					;if it's not, check right move
		
		gwpBnxt2:
			;YAY RECURSION MUCH FUN YAY
			sub #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, srcIndex, - , dstIndex, pc2
			cmp #1, timeUp
			beq packRec7
				jsr pc, prepMov
			
		gwpRB:
			mov 6(sp), 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result*, index, pc2
			jsr pc, isOnRght			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result*, index, pc2
			cmp 4(sp), #1				;checks if on Right border
			beq gwpLoopB				;if it is, check next tile
			
			add #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result*, #Board+index, pc2
			add #22, 2(sp)				;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result*, #Board+stepIndex, pc2
			cmp @2(sp), #1				;check who's on move tile
			bgt gwpLoopB 				;if contains black, check next tile
			blt gwpBnxt3				;if empty, continue to recursion
			
			sub #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result*, stepIndex, pc2
			jsr pc, isOnBtm				;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result2*, stepIndex, pc2
			cmp 4(sp), #1				;checks if left move tile is on bottom side
			beq gwpLoopB				;if it is, check next tile
			
			jsr pc, isOnRght			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result3*, stepIndex, pc2
			cmp 4(sp), #1				;checks if right move tile is on right side
			beq gwpLoopB				;if it is, check next tile
			
			add #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result3*, #Board+stepIndex, pc2
			add #22, 2(sp)				;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result3*, #Board+LEAPIndex, pc2
			cmp @2(sp), #0			;checks if right LEAP tile is 0 or not
			bne gwpLoopB				;if it's not, check next tile
			
		gwpBnxt3:
			;YAY RECURSION MUCH FUN YAY
			sub #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, srcIndex, - , dstIndex, pc2
			cmp #1, timeUp
			beq packRec7
				jsr pc, prepMov
				jmp gwpLoopB
			
		packRec7:	
			mov #1, stepInvalid
			mov 32(sp), -(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, srcIndex, - , dstIndex, pc2, #srcPos
			mov 32(sp), -(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, srcIndex, - , dstIndex, pc2, #srcPos, #DstPos
			mov 6(sp), @(sp)+			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, srcIndex, - , dstIndex, pc2, #srcPos
			mov 10(sp), @(sp)+			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, srcIndex, - , dstIndex, pc2
			rts pc
			
			
prepMov:								;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, srcIndex, - , dstIndex, pc2, pc3
			;getting ready for makeMov:
			mov 10(sp), r4				
			mov 4(sp),  r5
			mov #Board, -(sp)			;STACK: ..., #Board
			mov #Player, -(sp)			;STACK: ..., #Board, #Player
			mov Steps, -(sp)			;STACK: ..., #Board, #Player, Steps
			mov (r1), -(sp)				;STACK: ..., #Board, #Player, Steps, tempMax
			mov Player, -(sp)			;STACK: ..., #Board, #Player, Steps, tempMax, curPlayer
			jsr pc, makeMov				;STACK: ..., #Board, #Player, Steps, MAX_WP, curPlayer
			cmp 2(sp), (r1)				;assign the new MAX_WP and the previous one
			ble prepNext
			;if the new MAX_WP is bigger, update output:
			mov 2(sp), (r1)
			mov r4, (r2)
			mov r5, (r3)
		prepNext:
			add #12, sp					;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, srcIndex, - , dstIndex, pc2, pc3
			rts pc
			
			
gwpWhite: 
			mov #200, 6(sp) 			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, - , - , -, pc2
		gwpLoopW:		
			sub #2, 6(sp)				;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, - , -, pc2
			cmp 6(sp), #20
			bge gwpWnxt1				;if reached end of board, stops
				rts pc
		gwpWnxt1:
			mov 6(sp), 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, - , index, pc2
			add #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, - , #Board+index, pc2
			cmp @2(sp), #1			;checks if tile has white
			bne gwpLoopW				;if not, check next tile
			
			sub #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, - , index, pc2
			jsr pc, isOnLeft			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result*, index, pc2
			cmp 4(sp), #1				;checks if on left border
			beq gwpRW					;if it is, check right move
			
			add #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result*, #Board+index, pc2
			sub #22, 2(sp)				;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result*, #Board+stepIndex, pc2
			cmp @2(sp), #1				;check who's on move tile
			beq gwpRW 					;if contains white, check right move 
			blt gwpWnxt2				;if empty, continue to recursion
			
			sub #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result*, stepIndex, pc2
			jsr pc, isOnTop				;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result2*, stepIndex, pc2
			cmp 4(sp), #1				;checks if left move tile is on bottom side
			beq gwpRW					;if it is, check right move
			
			jsr pc, isOnLeft			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result3*, stepIndex, pc2
			cmp 4(sp), #1				;checks if left move tile is on left side
			beq gwpRW					;if it is, check right move
			
			add #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result3*, #Board+stepIndex, pc2
			sub #22, 2(sp)				;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result3*, #Board+LEAPIndex, pc2
			cmp @2(sp), #0			;checks if left LEAP tile is empty or not
			bne gwpRW					;if it's not, check right move
		
		gwpWnxt2:
			;YAY RECURSION MUCH FUN YAY
			sub #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, srcIndex, - , dstIndex, pc2
			cmp #1, timeUp
			beq packRec6
				jsr pc, prepMov
			
		gwpRW:
			mov 6(sp), 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result*, index, pc2
			jsr pc, isOnRght			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result*, index, pc2
			cmp 4(sp), #1				;checks if on Right border
			beq gwpLoopW				;if it is, check next tile
			
			add #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result*, #Board+index, pc2
			sub #16, 2(sp)				;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result*, #Board+stepIndex, pc2
			cmp @2(sp), #1				;check who's on move tile
			beq gwpLoopW 				;if contains white, check next tile
			blt gwpWnxt3				;if empty, continue to recursion
			
			sub #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result*, stepIndex, pc2
			jsr pc, isOnTop				;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result2*, stepIndex, pc2
			cmp 4(sp), #1				;checks if left move tile is on bottom side
			beq gwpLoopW				;if it is, check next tile
			
			jsr pc, isOnRght			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result3*, stepIndex, pc2
			cmp 4(sp), #1				;checks if right move tile is on right side
			beq gwpLoopW				;if it is, check next tile
			
			add #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result3*, #Board+stepIndex, pc2
			sub #16, 2(sp)				;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, index, *result3*, #Board+LEAPIndex, pc2
			cmp @2(sp), #0			;checks if right LEAP tile is empty or not
			bne gwpLoopW				;if it's not, check next tile
			
		gwpWnxt3:
			;YAY RECURSION MUCH FUN YAY
			sub #Board, 2(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, srcIndex, - , dstIndex, pc2
			cmp #1, timeUp
			beq packRec6
				jsr pc, prepMov
				jmp gwpLoopW

		packRec6:	
			mov #1, stepInvalid
			mov 32(sp), -(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, srcIndex, - , dstIndex, pc2, #srcPos
			mov 32(sp), -(sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, srcIndex, - , dstIndex, pc2, #srcPos, #DstPos
			mov 6(sp), @(sp)+			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, srcIndex, - , dstIndex, pc2, #srcPos
			mov 10(sp), @(sp)+			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, srcIndex, - , dstIndex, pc2
			rts pc
			
			
			




			
			
			
			
			
getMaxWP:	;Returns the best move to do and its WP
										;| STACK: SrcPos, DstPos, WinParam, pc
			mov #0, stepInvalid
			;check if Player Won:			
			mov r1, -(sp)				;| SrcPos | DstPos | WinParam | pc | r1 |
			mov 4(sp), r1				;r1 now holds WinParam address
			mov r4, -(sp)				;| SrcPos | DstPos | WinParam | pc | r1 | r4 |
			mov 12(sp), r4				;r4 now holds SrcPos address
			mov r5, -(sp)				;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 |
			mov 12(sp), r5				;r5 now holds DstPos
			mov r0, -(sp)				;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 |
			mov r2, -(sp)				;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 | r2 |
			mov r3, -(sp)				;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 | r2 | r3 |
			clr r0						;now used as an index for board tiles
			clr r2						; 
			clr r3						;both now used for calculations
			
			;getting ready for checkWin, if board was already at winning position we need to return 20 as WP and the src and dst of one of player's playpiece
										
			tst -(sp)					;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 | r2 | r3 | - |
			mov #Board, -(sp)			;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 | r2 | r3 | - | #Board |
			mov Player, -(sp)			;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 | r2 | r3 | - | #Board | Player |
			jsr pc, checkWin			;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 | r2 | r3 | *result* | #Board | Player | 
			cmp 4(sp), #1				;if Player hasn't won yet
			bne gwpNext1					;then continue
			
			;else release everything and return:
				mov #20, (r1)				;return 20 WP
				mov #Board, r0				;if board was already in a winning position we need to return a src and dst
				add #200, r0
		loopFindPlayer:		
				sub #2, r0
				cmp r0, #Board
				bge lfpNext
					tst (sp)+					;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 | r2 | r3 | *result* | #Board |
					tst (sp)+					;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 | r2 | r3 | *result* |
					tst (sp)+					;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 | r2 | r3 |
					br return
			lfpNext:
				cmp (r0), Player
				bne loopFindPlayer
					sub #Board, r0
					mov r0, (r4)
					mov r0, (r5)
					tst (sp)+					;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 | r2 | r3 | *result* | #Board |
					tst (sp)+					;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 | r2 | r3 | *result* |
					tst (sp)+					;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 | r2 | r3 |
		return:
					mov (sp)+, r3				;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 | r2 |
					mov (sp)+, r2				;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 |
					mov (sp)+, r0				;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 |
					mov (sp)+, r5				;| SrcPos | DstPos | WinParam | pc | r1 | r4 |
					mov (sp)+, r4				;| SrcPos | DstPos | WinParam | pc | r1 |
					mov (sp)+, r1				;| SrcPos | DstPos | WinParam | pc |
					rts pc
					
		;check if Adversary won:		
		gwpNext1:						;STACK: SrcPos, DstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, *result*, #Board, Player
			mov (sp), r2
			neg r2						;turning player to adversary (1 to 2 and 2 to 1)
			add #3, r2					;turning player to adversary (1 to 2 and 2 to 1)
			mov r2, (sp)				;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 | r2 | r3 | *result* | #Board | *Adversary* | 
			jsr pc, checkWin			;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 | r2 | r3 | *result2* | #Board | *Adversary* | 
			cmp 4(sp), #1
			bne gwpNext2				;If checkWin retuned -1, continue normally
			;else release everything and return:
				mov #177760, (r1)				;return -20 WP
				mov #Board, r0				;if board was already in a winning position we need to return a src and dst
				add #2, r0
				br loopFindPlayer
		
		;check if steps == 0:		
		gwpNext2:						;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, *result2*, #Board, *Adversary*
			mov Player, (sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, *result2*, #Board, Player
			cmp Steps, #0				;
			bne gwpNext3				;
			;releasing everything and returning:
				jsr pc, calcWP				;calcWP; puts result in r4
				mov r4, (r1)				;return calcWP
				tst (sp)+					;STACK: #srcPos, #dstPos, pc, r1, r4, r5, r0, r2, r3, *result2*, #Board
				tst (sp)+					;STACK: #srcPos, #dstPos, pc, r1, r4, r5, r0, r2, r3, *result2*
				tst (sp)+					;STACK: #srcPos, #dstPos, pc, r1, r4, r5, r0, r2, r3
				br return
		
		;if both players can't move, return tie. if only player can't, skip turn
		gwpNext3:						;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, result2, #Board, Player
			jsr pc, cntMoves			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, *PlayerMoves*, #Board, Player
			tst (sp)+					;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, *PlayerMoves*, #Board
			cmp 2(sp), #0				;check whether Player can make a move
			bgt gwpNext5				;if so, continue normally
			;else check if Adversary can make moves:
				mov Player, -(sp)		;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, *PlayerMoves*, #Board, Player
				neg (sp)				;turn Player into Adversary
				add #3, (sp)			;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, PlayerMoves, #Board, *Adversary*
				jsr pc, cntMoves		;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, *AdversaryMoves*, #Board, Adversary
				cmp 4(sp), #0			;check whether Adversary can make a move 
				bgt gwpNext4			;if so, skip Player's turn
				;else, return tie (if one of the players has more pieces than the other it would have returned 20 or -20 by now)
					mov #0, (r1)		
					mov Player, (sp)	;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, *AdversaryMoves*, #Board, Player
					mov #Board, r0
					add #200, r0
					br loopFindPlayer	
					
							
		gwpNext5:	;Checks which color is the player, and enters the respective recursion loop 						
										;|STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, - , #Board
										;| r0 - /accidently not used oops/ 
										;| r1 - #WinParam 
										;| r2 - #finalSrcPos 
										;| r3 - #finalDstPos 
										;| r4 - tempSrcPos 
										;| r5 - tempDstPos
			mov 26(sp), r2 				;assgin the adress of the final SrcPos 
			mov 24(sp), r3 				;assign the adress of the final DstPos
			mov 22(sp), r1				;assign the adress of the final WinParam
			mov #177757, (r1)			;temporarily assign a number lower than lowest score possible to WP 
			tst -(sp)					;STACK: #srcPos, #dstPos, WinParam, pc, r1, r4, r5, r0, r2, r3, *result3*, #Board, -
			cmp Player, #1			;check if current player is white or black
			beq gwpDoW
			jsr pc, gwpBlack
				
				add #6, sp
				br return
			
		gwpDoW:
			jsr pc, gwpWhite
				add #6, sp
				br return	
				
		goodTime:			
				mov #0, r4				;assign the same position to both SrcPos and DstPos, so it won't make any move
				mov #0, r5
				jsr pc, makeMov			;STACK: #srcPos, #dstPos, #WinParam, pc, r1, r4, r5, r0, r2, r3, *AdversaryMoves*, #Board, #Player, Steps, finalWP, Player
				mov 2(sp), (r1)
				add #6, sp				;STACK: #srcPos, #dstPos, #WinParam, pc, r1, r4, r5, r0, r2, r3, *AdversaryMoves*, #Board, #Player
				mov 30(sp), r4
				mov 26(sp), r5
				mov #Board, r0
				add #200, r0
				br loopFindPlayer
				
			gwpNext4:					;STACK: #srcPos, #dstPos, #WinParam, pc, r1, r4, r5, r0, r2, r3, *AdversaryMoves*, #Board, Adversary
				mov #Player, (sp)		;STACK: #srcPos, #dstPos, #WinParam, pc, r1, r4, r5, r0, r2, r3, *AdversaryMoves*, #Board, #Player
				mov Steps, -(sp)		;STACK: #srcPos, #dstPos, #WinParam, pc, r1, r4, r5, r0, r2, r3, *AdversaryMoves*, #Board, #Player, Steps
				mov #177757, -(sp)		;STACK: #srcPos, #dstPos, #WinParam, pc, r1, r4, r5, r0, r2, r3, *AdversaryMoves*, #Board, #Player, Steps, -21
				mov Player, -(sp)		;STACK: #srcPos, #dstPos, #WinParam, pc, r1, r4, r5, r0, r2, r3, *AdversaryMoves*, #Board, #Player, Steps, -21, Player
				cmp timeUp, #1
				bne goodTime
					jsr pc, stupdMov
					add #14, sp					;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 | r2 | r3 |
					cmp SrcPos, DstPos
					bne .+6				;->
					jmp loopFindPlayer
										;<-
						mov (sp)+, r3				;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 | r2 |
						mov (sp)+, r2				;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 | r0 |
						mov (sp)+, r0				;| SrcPos | DstPos | WinParam | pc | r1 | r4 | r5 |
						mov (sp)+, r5				;| SrcPos | DstPos | WinParam | pc | r1 | r4 |
						mov (sp)+, r4				;| SrcPos | DstPos | WinParam | pc | r1 |
						mov (sp)+, r1				;| SrcPos | DstPos | WinParam | pc |
						rts pc



calcWP:	
		;passes parameters for next function through the stack
		;								#Board, in stack
		;								Player, in stack
		;								returns WP in check
			
			tst -(sp)					;| board address | player | link reg | - |
			mov 6(sp), -(sp)			;| board address | player | link reg | - | board address |
			mov 6(sp), -(sp)			;| board address | player | link reg | - | board address | player |
			jsr pc, cntPlay				;| board address | player | link reg | number of pieces for player | board address | player |
			
			mov (sp), r4				;we want to check now how many playpieces the other player has
			neg r4
			add #3, r4
			mov r4, (sp)				;| board address | player | link reg | number of pieces for player | board address | *Adversary* |
			mov 4(sp), r4				
			jsr pc, cntPlay
			sub 4(sp), r4				;now r4 holds the WP
			add #6, sp					;| board address | player | link reg |
			rts pc
			
;~~~~




	;counts play pieces for current player
	;									
	
cntPlay:
					; | STACK:    -    , #Board, Player, pc 
					;input:		empty space for output				- in stack
					;			board address						- in stack
					;			player for which win is checked		- in stack
					;output:	number of play pieces for player	- in stack in empty space
			
			mov r0, -(sp)				;preserve r0, now used to hold the player's num
			mov 4(sp), r0
			mov r1, -(sp)				;preserve r1, now used to hold the address of board's tiles
			mov 10(sp), r1	
			mov r1, BoardS
			mov r2, -(sp)
			clr r2						;preserve r2, now used to count playpieces
			
			add #200, r1
			
			
	loop1:
			dec r1
			dec r1
			cmp r1, BoardS
			blt exit2
			
				cmp (r1), r0
				bne loop1
			
					inc r2
					br loop1
	exit2:		
	
			mov r2, 14(sp)
			mov (sp)+, r2
			mov (sp)+, r1
			mov (sp)+, r0
			rts pc

	BoardS:	.blkw 1						;gonna hold the addresses of the end of the game board and beginning








;~~~~



	
canMove:	;checks if both players can't move, if so returns 1, else returns -1
			tst -(sp)					;| - | board address | link reg | - |
			mov 4(sp), -(sp)			;| - | board address | link reg | - | board address | 
			mov #1, -(sp)				;| - | board address | link reg | - | board address | 1 |
			jsr pc, cntMoves			;| - | board address | link reg | (moves for player 1) | board address | 1 |
			tst 4(sp)
			bne cmExit2
			
				mov #2, (sp)			
				jsr pc, cntMoves		;| - | board address | link reg | (moves for player 2) | board address | 2 |
				tst 4(sp)
				bne cmExit2
			
					mov #1, 12(sp)		;if none can move, we want to return 1
					add #6, sp
					rts pc
					
cmExit2:		mov #-1, 12(sp)				;can move, return -1
			add #6, sp
			rts pc
			
			
			
			

;~~~~			
			
			
			
			
			
makeMov:	;makes a move and checks the best WP awarded by this move
										;input:	 	src tile 								- in r4
										;			dest tile								- in r5
										;			Board address 							- in stack
										;			player address							- in stack
										;			steps left								- in stack
										;			local_max or min to compare the WP with - in stack
										;			current player 							- in stack
										;output: 	best WP awarded by the move when using the minimax algorithm - updated in stack in the stead of the local_max
										
					;| STACK: Board address, #player, steps left, local_max or min, current player, pc (link reg)
					
			mov r0, -(sp)				;| #Board | #Player | steps | local_max or min | curr_player | pc | r0 |
			mov r1, -(sp)				;| #Board | #Player | steps | local_max or min | curr_player | pc | r0 | r1 |
			mov r2, -(sp)				;| #Board | #Player | steps | local_max or min | curr_player | pc | r0 | r1 | r2 |
			clr r0						;used for calculations
			clr r1						;used for calculations
			clr r2						;used for calculations
			tst -(sp)					;| #Board | #Player | steps | local_max or min | curr_player | pc | r0 | r1 | r2 | - |
			mov 22(sp), -(sp)			;| #Board | #Player | steps | local_max or min | curr_player | pc | r0 | r1 | r2 | - | #Board |
										;preparation for movPiece function
			mov r4, MovSrc				;
			mov r5, MovDst				;preparation for the movpiece function
			jsr r5, movPiece
			MovSrc:		.blkw 1
			MovDst:		.blkw 1
			
			mov 22(sp), -(sp)			;| #Board | #Player | steps | local_max or min | curr_player | pc | r0 | r1 | r2 | - | #Board | #Player |
			mov 22(sp), r1				;move steps into r1 to decrease, since we are going one level deeper in recursion
			dec r1
			mov r1, -(sp)				;| #Board | #Player | steps | local_max or min | curr_player | pc | r0 | r1 | r2 | - | #Board | #Player | steps - 1 |
			
			mov r4, r0					;preperation for a check if move is a leap
			sub r5, r0					;
			bgt positive				;
				neg r0					;absolute value |r0|
		positive:
			cmp r0, #22				;comparing the distance jumped (r0) and farthest distance traversed in a one tile diagonal move (SkipFar)
										;r0 > skipF only if a leap has occured
			ble noLeap
				mov r4, r2					;
				add r5, r2					;
				asr r2						;used to delete leapt over piece
				mov #0, Board(r2)
				
		noLeap:
				;if no leap occured can start recursion immidiately, otherwise, delete leapt over player and then start recursion
			mov 20(sp), r1				;move curr_player to register
			neg r1						;
			add #3, r1					;used to change player for the next turn (getWP_aux)
			mov r1, -(sp)				;| #Board | #Player | steps | local_max or min | curr_player | pc | r0 | r1 | r2 | - | #Board | #Player | steps - 1 | adversary |
			jsr pc, getWP_aux			;| #Board | #Player | steps | local_max or min | curr_player | pc | r0 | r1 | r2 | *local_max or min of son* | #Board | #Player | - >
										;- >	  | steps - 1 | adversary |
			add #6, sp					;| #Board | #Player | steps | local_max or min | curr_player | pc | r0 | r1 | r2 | local_max or min of son | #Board |
			mov r4, -(sp)				;| #Board | #Player | steps | local_max or min | curr_player | pc | r0 | r1 | r2 | local_max or min of son | #Board | r4 |
										;preparation for minOrMax function, which returns its result in r4
			mov 16(sp), -(sp)			;| #Board | #Player | steps | local_max or min | curr_player | pc | r0 | r1 | r2 | local_max or min of son | #Board | r4 | curr_player |
			mov 26(sp), -(sp)			;| #Board | #Player | steps | local_max or min | curr_player | pc | r0 | r1 | r2 | local_max or min of son | #Board | r4 | curr_player | #Player |
			jsr pc, minOrMax
			add #4, sp					;| #Board | #Player | steps | local_max or min | curr_player | pc | r0 | r1 | r2 | local_max or min of son | #Board | r4 |

			tst r4						;if = 1, we want to find the maximum of the results gathered by a recursive call to getWP_aux
			blt findMin
				cmp 4(sp), 20(sp)			;r4 is indicating we are looking for a maximal value, if the local_max or min of tree's son is bigger than value -
				blt reverse					; - in root (20(sp)), replace it and start undoing move				
					mov 4(sp), 20(sp)			;| #Board | #Player | steps | local_max or min (updated) | curr_player | pc | r0 | r1 | r2 | local_max or min of son | #Board | r4 |
					br reverse					
		findMin:	
		
			cmp 4(sp), 20(sp)			;r4 is indicating we are looking for a minimal value, if local_max or min of tree's son is smaller than value in root (20(sp)) -
			bgt reverse					; - replace it and start undoing move
				mov 4(sp), 20(sp)				;| #Board | #Player | steps | local_max or min (updated) | curr_player | pc | r0 | r1 | r2 | local_max or min of son | #Board | r4 |
			
		reverse:
		
			mov (sp), r4				;move src pos back from stack into r4
			add #6, sp					;| #Board | #Player | steps | local_max or min (updated) | curr_player | pc | r0 | r1 | r2 |
			cmp r0, #22				;comparing the distance jumped (r0, calculated earlier in code) and farthest distance traversed in a one tile -
										; - diagonal move (SkipFar) r0 > skipF only if a leap has occured
			ble noLeapReverse
				mov 10(sp), r1				;r1 has the value of current player now
				neg r1						;
				add #3, r1					;using r1 to recreate the number of player whose piece was destroyed by being leapt over.
				mov r1, Board(r2)			;r2 is the pointer to the tile where the leapt over piece was
				
		noLeapReverse:

			mov 20(sp), -(sp)			;| #Board | #Player | steps | local_max or min (updated) | curr_player | pc | r0 | r1 | r2 | #Board |
			mov r4, RvrsDst				;
			mov r5, RvrsSrc				;preparation for the movpiece function to undo game move
			jsr r5, movPiece
				
			RvrsSrc:	.blkw 1
			RvrsDst:	.blkw 1
			
			tst (sp)+					;| #Board | #Player | steps | local_max or min (updated) | curr_player | pc | r0 | r1 | r2 |
			mov (sp)+, r2				;| #Board | #Player | steps | local_max or min (updated) | curr_player | pc | r0 | r1 |
			mov (sp)+, r1				;| #Board | #Player | steps | local_max or min (updated) | curr_player | pc | r0 |
			mov (sp)+, r0				;| #Board | #Player | steps | local_max or min (updated) | curr_player | pc |
			rts pc
					
			
			

minOrMax:	;returns whether we currently look for maximum WP or minimum WP 
										;		 	curPlayer 								- in stack
										;			#Player									- in stack
										;output:	1 if max, -1 if min						- in r4
										;STACK: curPlayer, #Player, pc
			mov #1, r4
			cmp 4(sp), @2(sp)
			beq momNext
			mov #-1, r4
		momNext:
			rts pc		
			
			
			
			
			
			
getWP_aux:
		;returns the best WP for curPlayer
										
										;			empty space for output 					- in stack
										;			#Board									- in stack
										;			#originPlayer							- in stack
										;			steps left								- in stack
										;			curPlayer	 							- in stack
										;output: 	the best WP for curPlayer
										;STACK: - , #Board, #Player, steps, curPlayer, pc
			;getting ready for checkWin, if board was already at winning position we need to return 20 as WP and the src and dst of one of player's playpiece
			tst -(sp)					;STACK: - , #Board, #Player, steps, curPlayer, pc, - 
			mov 12(sp), -(sp)			;STACK: - , #Board, #Player, steps, curPlayer, pc, - , #Board
			mov @12(sp), -(sp)			;STACK: - , #Board, #Player, steps, curPlayer, pc, - , #Board, Player
			jsr pc, checkWin			;STACK: - , #Board, #Player, steps, curPlayer, pc, *result*, #Board, Player
			cmp 4(sp), #1				;if Player hasn't won yet
			bne gwpaBr1					;then continue
			;else release everything and return:
				mov #20, 20(sp)			;STACK: 20, #Board, #Player, steps, curPlayer, pc, *result*, #Board, Player
				tst (sp)+					;STACK: 20, #Board, #Player, steps, curPlayer, pc, *result*, #Board
				tst (sp)+					;STACK: 20, #Board, #Player, steps, curPlayer, pc, *result*
				tst (sp)+					;STACK: 20, #Board, #Player, steps, curPlayer, pc
				rts pc
				
		gwpaBr1:
			neg (sp)
			add #3, (sp)				;STACK: - , #Board, #Player, steps, curPlayer, pc, *result*, #Board, *Adversary*
			jsr pc, checkWin			;STACK: - , #Board, #Player, steps, curPlayer, pc, *result2*, #Board, *Adversary*
			cmp 4(sp), #1				;if Adversary hasn't won yet
			bne gwpaBr2					;continue
			;else release everything and return:
				mov #177760, 20(sp)			;STACK: -20, #Board, #Player, steps, curPlayer, pc, *result2*, #Board, *Adversary*
				tst (sp)+ 					;STACK: -20, #Board, #Player, steps, curPlayer, pc, *result2*, #Board
				tst (sp)+					;STACK: -20, #Board, #Player, steps, curPlayer, pc, *result2*
				tst (sp)+					;STACK: -20, #Board, #Player, steps, curPlayer, pc
				rts pc
				
		gwpaBr2:
			mov @14(sp), (sp)			;STACK: - , #Board, #Player, steps, curPlayer, pc, *result2*, #Board, Player
			cmp 12(sp), #0				;check if any steps left
			bne gwpaBr3					;if there are, continue
			;else release everything and return:
				tst (sp)+					;STACK: newWP, #Board, #Player, steps, curPlayer, pc, *result2*, #Board
				tst (sp)+					;STACK: newWP, #Board, #Player, steps, curPlayer, pc, *result2*
				mov r4, -(sp)				;STACK: - , #Board, #Player, steps, curPlayer, pc, *result2*, ^r4
				mov 14(sp), -(sp)			;STACK: - , #Board, #Player, steps, curPlayer, pc, *result2*, ^r4, #Board
				mov @14(sp), -(sp)			;STACK: - , #Board, #Player, steps, curPlayer, pc, *result2*, ^r4, #Board, originPlayer
				jsr pc, calcWP				;calcWP, puts result in r4
				mov r4, 22(sp)				;STACK: newWP, #Board, #Player, steps, curPlayer, pc, *result2*, ^r4, #Board, originPlayer
				tst (sp)+					;STACK: newWP, #Board, #Player, steps, curPlayer, pc, *result2*, ^r4, #Board
				tst (sp)+					;STACK: newWP, #Board, #Player, steps, curPlayer, pc, *result2*, ^r4
				mov (sp)+, r4				;STACK: newWP, #Board, #Player, steps, curPlayer, pc, *result2*
				tst (sp)+					;STACK: newWP, #Board, #Player, steps, curPlayer, pc
				rts pc
					
		gwpaBr3:
			tst (sp)+					;STACK: - , #Board, #Player, steps, curPlayer, pc, *result2*, #Board
			jsr pc, canMove				;STACK: - , #Board, #Player, steps, curPlayer, pc, *result3*, #Board
			cmp 2(sp), #1				;both players can't move?
			bne gwpaBr4					;if not (=if one of them can move), continue
			;else release everything and return:
				mov #0, 16(sp) 				;STACK: 0, #Board, #Player, steps, curPlayer, pc, *result3*, #Board
				tst (sp)+					;STACK: 0, #Board, #Player, steps, curPlayer, pc, *result3*
				tst (sp)+					;STACK: 0, #Board, #Player, steps, curPlayer, pc
				rts pc
				
		gwpaBr4:
			mov #177757, 16(sp) 
			mov r4, -(sp)				;STACK: L , #Board, #Player, steps, curPlayer, pc, *result3*, #Board, ^r4
			mov 10(sp), -(sp)			;STACK: L , #Board, #Player, steps, curPlayer, pc, *result3*, #Board, ^r4, curPlayer
			mov 16(sp), -(sp)			;STACK: L , #Board, #Player, steps, curPlayer, pc, *result3*, #Board, ^r4, curPlayer, #Player
			jsr pc, minOrMax
			cmp r4, #1
			beq gwpaBr5
			mov #21, 24(sp)		;STACK: H , #Board, #Player, steps, curPlayer, pc, *result3*, #Board, ^r4, curPlayer, #Player
		gwpaBr5:
			tst (sp)+					;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, *result3*, #Board, ^r4, curPlayer
			tst (sp)+					;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, *result3*, #Board, ^r4
			mov (sp), r4
			
			cmp 10(sp), #1
			beq gwpaW
			jsr pc, gwpaDoB
			;release everything and return:
			return2:
				tst (sp)+					;STACK: - , #Board, #Player, steps, curPlayer, pc, *result3*, #Board
				tst (sp)+					;STACK: - , #Board, #Player, steps, curPlayer, pc, *result3*
				tst (sp)+					;STACK: - , #Board, #Player, steps, curPlayer, pc
				rts pc
		gwpaW:
			jsr pc, gwpaDoW
				br return2
				
				
				
				
gwpaDoB:								;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, - , - , -, pc2
			mov #-2, 6(sp) 				;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, -2 , - , -, pc2 
		gwpaBbr1:		
			add #2, 6(sp)				;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index , - , -, pc2
			cmp 6(sp), #160
			blt .+4					;if reached end of board, stops
				rts pc
			mov 6(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, - , index, pc2
			add 20(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, - , #Board+index, pc2
			cmp @2(sp), #2			;checks if tile has black
			bne gwpaBbr1				;if not, check next tile
			
			sub 20(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, - , index, pc2
			jsr pc, isOnLeft			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result*, index, pc2
			cmp 4(sp), #1				;checks if on left border
			beq gwpaRB					;if it is, check right move
			
			add 20(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result*, #Board+index, pc2
			add #16, 2(sp)				;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result*, #Board+stepIndex, pc2
			cmp @2(sp), #1				;check who's on move tile
			bgt gwpaRB 					;if contains black, check right move 
			blt gwpaBbr3				;if empty, continue to recursion
			
			sub 20(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result*, stepIndex, pc2
			jsr pc, isOnBtm				;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result2*, stepIndex, pc2
			cmp 4(sp), #1				;checks if left move tile is on bottom side
			beq gwpaRB					;if it is, check right move
			
			jsr pc, isOnLeft			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result3*, stepIndex, pc2
			cmp 4(sp), #1				;checks if left move tile is on left side
			beq gwpaRB					;if it is, check right move
			
			add 20(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result3*, #Board+stepIndex, pc2
			add #16, 2(sp)				;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result3*, #Board+LEAPIndex, pc2
			cmp @2(sp), #0			;checks if left LEAP tile is empty or not
			bne gwpaRB					;if it's not, check right move
		
		;the recursion part:
		gwpaBbr3:
			;YAY RECURSION MUCH FUN YAY
			sub #Board, 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, srcIndex, - , dstIndex, pc2
			jsr pc, gwpaPrep			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, srcIndex, 1/0 , dstIndex, pc2
			tst 4(sp)					;if flag is on 1, time is up. unload recursion
			bne packRec4
			
		gwpaRB:
			mov 6(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result*, index, pc2
			jsr pc, isOnRght			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result*, index, pc2
			cmp 4(sp), #1				;checks if on Right border
			beq gwpaBbr1				;if it is, check next tile
			
			add 20(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result*, #Board+index, pc2
			add #22, 2(sp)				;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result*, #Board+stepIndex, pc2
			cmp @2(sp), #1				;check who's on move tile
			bgt gwpaBbr1 				;if contains black, check next tile
			blt gwpaBbr4				;if empty, continue to recursion
			
			sub 20(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result*, stepIndex, pc2
			jsr pc, isOnBtm				;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result2*, stepIndex, pc2
			cmp 4(sp), #1				;checks if left move tile is on bottom side
			beq gwpaBbr1				;if it is, check next tile
			
			jsr pc, isOnRght			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result3*, stepIndex, pc2
			cmp 4(sp), #1				;checks if right move tile is on right side
			beq gwpaBbr1				;if it is, check next tile
			
			add 20(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result3*, #Board+stepIndex, pc2
			add #22, 2(sp)				;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result3*, #Board+LEAPIndex, pc2
			cmp @2(sp), #0			;checks if right LEAP tile is empty or not
			bne gwpaBbr1				;if it's not, check next tile
			
		gwpaBbr4:
			;YAY RECURSION MUCH FUN YAY
			sub 20(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, srcIndex, - , dstIndex, pc2
			jsr pc, gwpaPrep			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, srcIndex, 1/0 , dstIndex, pc2
			tst 4(sp)					;if flag is on 1, time is up. unload recursion
			bne packRec4
				jmp gwpaBbr1

		packRec4:
			mov #1, stepInvalid			;indicate that 
			rts pc
			
			
			
		
		
		
		
				
gwpaDoW:								;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, - , - , -, pc2
			mov #200, 6(sp) 			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, -2 , - , -, pc2 
		gwpaWbr1:		
			sub #2, 6(sp)				;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index , - , -, pc2
			cmp 6(sp), #20
			bge .+4					;if reached end of board, stops
				rts pc
			mov 6(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, - , index, pc2
			add 20(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, - , #Board+index, pc2
			cmp @2(sp), #1			;checks if tile has white
			bne gwpaWbr1				;if not, check next tile
			
			sub 20(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, - , index, pc2
			jsr pc, isOnLeft			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result*, index, pc2
			cmp 4(sp), #1				;checks if on left border
			beq gwpaRW					;if it is, check right move
			
			add 20(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result*, #Board+index, pc2
			sub #22, 2(sp)				;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result*, #Board+stepIndex, pc2
			cmp @2(sp), #1				;check who's on move tile
			beq gwpaRW 					;if contains white, check right move 
			blt gwpaWbr3				;if empty, continue to recursion
			
			sub 20(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result*, stepIndex, pc2
			jsr pc, isOnTop				;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result2*, stepIndex, pc2
			cmp 4(sp), #1				;checks if left move tile is on top side
			beq gwpaRW					;if it is, check right move
			
			jsr pc, isOnLeft			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result3*, stepIndex, pc2
			cmp 4(sp), #1				;checks if left move tile is on left side
			beq gwpaRW					;if it is, check right move
			
			add 20(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result3*, #Board+stepIndex, pc2
			sub #22, 2(sp)				;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result3*, #Board+LEAPIndex, pc2
			cmp @2(sp), #0			;checks if left LEAP tile is empty or not
			bne gwpaRW					;if it's not, check right move
		
		;the recursion part:
		gwpaWbr3:
			;YAY RECURSION MUCH FUN YAY
			sub 20(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, srcIndex, - , dstIndex, pc2
			jsr pc, gwpaPrep			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, srcIndex, 1/0 , dstIndex, pc2
			tst 4(sp)					;if flag is on 1, time is up. unload recursion
			bne packRec3
			
		gwpaRW:
			mov 6(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result*, index, pc2
			jsr pc, isOnRght			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result*, index, pc2
			cmp 4(sp), #1				;checks if on Right border
			beq gwpaWbr1				;if it is, check next tile
			
			add 20(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result*, #Board+index, pc2
			sub #16, 2(sp)				;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result*, #Board+stepIndex, pc2
			cmp @2(sp), #1				;check who's on move tile
			beq gwpaWbr1 				;if contains white, check next tile
			blt gwpaWbr4				;if empty, continue to recursion
			
			sub 20(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result*, stepIndex, pc2
			jsr pc, isOnTop				;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result2*, stepIndex, pc2
			cmp 4(sp), #1				;checks if left move tile is on top side
			beq gwpaWbr1				;if it is, check next tile
			
			jsr pc, isOnRght			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result3*, stepIndex, pc2
			cmp 4(sp), #1				;checks if right move tile is on right side
			beq gwpaWbr1				;if it is, check next tile
			
			add 20(sp), 2(sp)			;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result3*, #Board+stepIndex, pc2
			sub #16, 2(sp)				;STACK: tempWP, #Board, #Player, steps, curPlayer, pc, index, *result3*, #Board+LEAPIndex, pc2
			cmp @2(sp), #0			;checks if right LEAP tile is empty or not
			bne gwpaWbr1				;if it's not, check next tile
			
		gwpaWbr4:
			;YAY RECURSION MUCH FUN YAY
			sub 20(sp), 2(sp)			;STACK:  tempWP, #Board, #Player, steps, curPlayer, pc, srcIndex, - , dstIndex, pc2
			jsr pc, gwpaPrep			;STACK:  tempWP, #Board, #Player, steps, curPlayer, pc, srcIndex, 1/0 , dstIndex, pc2
			tst 4(sp)					;if flag is on 1, time is up. unload recursion
			bne packRec3
				jmp gwpaWbr1		
		
		packRec3:
			mov #1, stepInvalid			;indicate that recursion run has been interrupted by timeup
			rts pc

		
		
		
		

			
cntMoves:	
				;| STACK:   -   , #Board, Player, pc
				;input: empty space for output  	- in stack
				;		Player						- in stack
				;		board address				- in stack
				;output: number of possible moves 	- in empty space in stack
			mov r0, -(sp)							;preserving r0, now used as an index for game tiles
			mov 6(sp), r0
			mov r0, BoardB
			mov r0, BoardE
			mov r0, BordLRo
			add #176, BoardE
			add #160, BordLRo
			mov r1, -(sp)							;preserving r1, now used to count the possible moves
			clr r1
			mov r2, -(sp)							;preserving r2, now used for calculations
			mov r3, -(sp)							;preserving r3, now used for calculations
			mov r4, -(sp)							;preserving r4, now used to hold player's turn
			mov 14(sp) , r4
			
			add #156, r0							;starts to go throught indexes from the end to beginning
			cmp #2, r4			
			beq loopB
			
				sub #136, r0						;starts at the second last row, because there is no use checking for the last row
				br loopW							;checks whose turn it is
			
		;a loop for counting possible moves in case player is Black
			
	loopB:
			cmp (r0), #2
			bne nextB								;if not Black, proceed to nextB tile
			
	;Black left border check:			

				mov r0, r3							;for r2r3 we check if r3(mod 20) == 0, which means we're at the left border
				sxt r2					
				div #20, r2
				cmp r3, #0						;if on left border - 
				beq tileRB							; - proceed to check right move tile (skip the right border check)			
			
	;B left occupation check:
		
			mov r0, r3
			add #16, r3
			cmp (r3), #1
			bgt borderRB 							;if left move tile has Black, proceed to check right border
			beq leapLB								;if left move tile has White, proceed to check left leap
					
				inc r1								;else increase numOfSteps by 1
				br borderRB							;proceed to check the right border 

		;checks if player can leap (eat) the playpiece on its left
			
	leapLB:	
			cmp r3, BordLRo							;if White is at last row -
			bge borderRB							; - proceed to check right border
			
				tst r3
				sxt r2	
				div #20, r2
				cmp r3, #0						;if White is at left border - 
				beq borderRB						; - proceed to check right border
				
					mov r0, r3					
					add #16, r3
					add #16, r3	
					cmp (r3), #0				;if left leap tile is occupied - 
					bne borderRB					; - proceed to check right border
					
						inc r1						;else increase numOfSteps by 1
						br borderRB					;proceed to check the right border
					
		;Black right border check:
		
	borderRB:	
			mov r0, r3
			sxt r2
			div #20, r2
			cmp r3, #16							;if on right border - 
			beq nextB								;proceed to nextB tile
			
		;the label signifies a situation where we want to check if Black player can proceed to the right diagonal, when we know he is not on the right border
			
	tileRB:
			mov r0, r3
			add #22, r3
			cmp (r3), #1			
			bgt nextB								;if right move tile has Black, proceed to nextB tile
			
				beq leapRB							;if right move tile has White, proceed to check right leap 
				
					inc r1							;else increase numOfSteps by 1
					br nextB						; proceed to nextB tile
			
		;checks if player can leap (eat) the playpiece on its right
			
	leapRB:	
			cmp r3, BordLRo							;if White is at last row - 			
			bge nextB								; - proceed to nextB tile
			
				tst r3
				sxt r2
				div #20, r2
				cmp r3, #16						;if White is at right border - 
				beq nextB							;proceed to nextB tile
				
					mov r0, r3
					add #22, r3					
					add #22, r3					
					cmp (r3), #0				;if right leap tile is occupied - 
					bne nextB						; - proceed to nextB tile
					
						inc r1						;else increase numOfSteps by 1
						br nextB

		;checks next tile for moves.
						
	nextB:
			sub #2, r0								;going from end to start, each tile a word (so *2* bytes)
			cmp r0, BoardB
			bge loopB
				
		;unfold routine and Empty the stack
		
				mov r1, 20(sp)
				mov (sp)+, r4
				mov (sp)+, r3
				mov (sp)+, r2
				mov (sp)+, r1
				mov (sp)+, r0		
				rts pc

		;a loop for counting possible moves in case player is White			
			
	loopW:		
			cmp (r0), r4					;checks wether current tile has a White playpiece
			bne nextW						;if not checks next tile
			
				mov r0, r3						;
				sxt r2							;
				div #20, r2						;finds the reminders of the index, each even reminder between 0 - 20 (excluding) indicates a different horizontal location
			
				cmp r3, #0
				beq tileRW					;if it's right by the left ledge, move is illegal, there's no need to check if next to right ledge, since it is 
											;obviously by the left ledge.
			
			mov r0, r3					
			sub #22, r3				
			
			cmp (r3), #1				;if space has a White playpiece, it cannot jump there
			beq borderRW
				cmp (r3), #2			;if space has a Black playpiece try and initiate eat
				beq leapLW					
					inc r1					;otherwise space is Empty so a move is possible
					br borderRW
	
		;checks if player can leap (eat) the playpiece on its left
	
	leapLW:
			tst r3
			sxt r2						
			div #20, r2						;finds the reminders of the index, to determine if close to the left
			
			cmp r3, #0
			beq borderRW					;if it's right by the left ledge, move is illegal

				mov r0,r3					;otherwise, check if close to ledge has destroyed r2, we have to recreate the checked index and find now the third 
				sub #22, r3				;diagonal tile away from checked tile
				sub #22, r3				;
				cmp r3, BoardB
				blt borderRW				;if index is negative that must mean eating would get the piece out of bounds.
				
					cmp (r3), #0		;if space is Empty count as eat
					bne borderRW
					inc r1					;eating is possible. now to check a move to the right
					br borderRW
			
		;checks if playpiece is on the right border (check if can jump to the right)
		
	borderRW:
			mov r0, r3						;
			sxt r2							;
			div #20, r2						;finds the reminders of the index, each even reminder between 0 - 20 (excluding) indicates a different horizontal location
						
			cmp r3, #16
			beq nextW						;if it's right by the right ledge, move is illegal, check the next tile
			
		;the label signifies a situation where we want to check if Black player can proceed to the right diagonal, when we know he is not on the right border
			
			
	tileRW:
			mov r0, r3						;
			sub #16, r3					;
			cmp (r3), #1				;if space has a White playpiece, it cannot jump there
			beq nextW
				cmp (r3), #2			;if space has a Black playpiece try and initiate eat
				beq leapRW
				inc r1						;otherwise space is Empty so a move is possible
				br nextW
		
		;checks if player can leap (eat) the playpiece on its left
	
	leapRW:	
			tst r3
			sxt r2						
			div #20, r2						;finds the reminders of the index, to determine if close to the right
			
			cmp r3, #16
			beq nextW						;if it's right by the right ledge, move is illegal
			
				mov r0,r3					;otherwise, check if close to ledge has destroyed r2, we have to recreate the checked index and find now the third 
				sub #16, r3				;diagonal tile away from checked tile
				sub #16, r3				;
				cmp r3, BoardB				;
				blt nextW					;if index is negative, that must mean eating would get the piece out of bounds.
			
				cmp (r3), #0			;if space is Empty count as eat
				bne nextW
					inc r1					;eating is possible. now to check the nextW tile
					br nextW				;checkes nextW tile

		;check next tile index
			
	nextW:	
			add #2, r0						;check nextW tile
			cmp r0, BoardE					;if index is 176 board has been scanned top to bottom -> halt
			ble loopW

		;unfold routine and Empty the stack
		
				mov r1, 20(sp)
				mov (sp)+, r4
				mov (sp)+, r3
				mov (sp)+, r2
				mov (sp)+, r1
				mov (sp)+, r0			
				rts pc
		
BoardB:		.blkw 1						;gonna hold the addresses of the end of the game board and beginning
BoardE:		.blkw 1						;
BordLRo:	.blkw 1						;address of the first tile in the last row of the board







;~~~~






		

			


isOnLeft:	;checks whether a certain index is on the first column of the board - returns 1 if yes, 0 if not
			;										LR - pc
			;										the index - in stack (on top of the stack)
			;										output - in stack (below the index)
			;														| STACK: ..., - (place_for_output), index, pc
			clr 6(sp)					;set result to 0 by default	| STACK: ..., 0, index, - , pc
			mov r0, -(sp)				;							| STACK: ..., 0, index, - , pc, ^r0
			mov r1, -(sp)				;							| STACK: ..., 0, index, - , pc, ^r0, ^r1
			mov 10(sp), r1				;							| STACK: ..., 0, index, - , pc, ^r0, ^r1
			sxt r0
			div #20, r0
			cmp r1, #0
			bne .+10					;if playpiece isnt on the left skip next command and return 0
				mov #1, 12(sp)				;set result to 1			| STACK: ..., 1, index, - , pc, ^r0, ^r1

			mov (sp)+, r1				;							| STACK: ..., 0/1, index, - , pc, ^r0
			mov (sp)+, r0				;							| STACK: ..., 0/1, index, - , pc
			rts pc
			
			
isOnRght:	;checks whether a certain index is on the last column of the board - returns 1 if yes, 0 if not
			;										LR - pc
			;										the index - in stack (on top of the stack)
			;										output - in stack (below the index)
			;														| STACK: ..., - , index, - , pc
			clr 6(sp)					;set result to 0 by default	| STACK: ..., 0, index, - , pc
			mov r0, -(sp)				;							| STACK: ..., 0, index, - , pc, ^r0
			mov r1, -(sp)				;							| STACK: ..., 0, index, - , pc, ^r0, ^r1
			mov 10(sp), r1				;							| STACK: ..., 0, index, - , pc, ^r0, ^r1
			sxt r0
			div #20, r0
			cmp r1, #16					;if playpiece isnt on the right skip next command and return 0
			bne .+10		
				mov #1, 12(sp)				;set result to 1			| STACK: ..., 1, index, - , pc, ^r0, ^r1
		
			mov (sp)+, r1				;							| STACK: ..., 0/1, index, - , pc, ^r0
			mov (sp)+, r0				;							| STACK: ..., 0/1, index, - , pc
			rts pc
			
			
			
isOnTop:	;checks whether a certain index is on the first row of the board - returns 1 if yes, 0 if not
			;										LR - pc
			;										the index - in stack (on top of the stack)
			;										output - in stack (below the index)
			;														| STACK: ..., - , index, - , pc
			clr 6(sp)					;set result to 0 by default	| STACK: ..., 0, index, - , pc
			mov r0, -(sp)				;							| STACK: ..., 0, index, - , pc, ^r0
			mov 6(sp), r0				;							| STACK: ..., 0, index, - , pc, ^r0
			cmp r0, #20						;if playpiece isnt on top skip next command and return 0
			bge .+10
				mov #1, 10(sp)				;set result to 1			| STACK: ..., 1, index, - , pc, ^r0

			mov (sp)+, r0				;							| STACK: ..., 0/1, index, - , pc
			rts pc
			

isOnBtm:	;checks whether a certain index is on the last row of the board - returns 1 if yes, 0 if not
			;										LR - pc
			;										the index - in stack (on top of the stack)
			;										output - in stack (below the index)
			;														| STACK: ..., - , index, , - , pc
			clr 6(sp)					;set result to 0 by default	| STACK: ..., 0, index, - , pc
			mov r0, -(sp)				;							| STACK: ..., 0, index, - , pc, ^r0
			mov 6(sp), r0				;							| STACK: ..., 0, index, - , pc, ^r0
			cmp r0, #156
			ble .+10						;if r0 isnt on bottom skip next command
				mov #1, 10(sp)				;set result to 1			| STACK: ..., 1, index, - , pc, ^r0

			mov (sp)+, r0				;							| STACK: ..., 0/1, index, - , pc
			rts pc
			
			
stupdMov:
				;input: #srcAddress 				- in r4
				;		#dstAddress					- in r5
				;		Player						- in common area
				;		board address				- in common area
				;output: fills in srcAddress and dstAddress for any possible move
			mov r0, -(sp)							;preserving r0, now used as an index for game tiles
			mov #Board, r0
			mov r0, BoardB
			mov r0, BoardE
			mov r0, BordLRo
			add #176, BoardE
			add #160, BordLRo
			mov r1, -(sp)							;preserving r1, now used to count the possible moves
			clr r1
			mov r2, -(sp)							;preserving r2, now used for calculations
			mov r3, -(sp)							;preserving r3, now used for calculations
			mov r4, -(sp)							;preserving r4, now used to hold player's turn
			mov Player , r4
			
			add #156, r0							;starts to go through indexes from the end to beginning
			cmp #2, r4			
			beq loopb
			
				sub #136, r0						;starts at the second last row, because there is no use checking for the last row
				br loopw1							;checks whose turn it is
			
		;a loop for counting possible moves in case player is Black
			
	loopb:
			cmp (r0), #2
			bne nextb								;if not Black, proceed to nextB tile
			
	;Black left border check:			

				mov r0, r3							;for r2r3 we check if r3(mod 20) == 0, which means we're at the left border
				sxt r2					
				div #20, r2
				cmp r3, #0						;if on left border - 
				beq tilerb							; - proceed to check right move tile (skip the right border check)			
			
	;B left occupation check:
		
			mov r0, r3
			add #16, r3
			cmp (r3), #1
			bgt borderrb 							;if left move tile has Black, proceed to check right border
			beq leaplb								;if left move tile has White, proceed to check left leap
					
				br packRec5							;found a legal move, wrap function

		;checks if player can leap (eat) the playpiece on its left

	loopw1: br loopw
			
	leaplb:	
			cmp r3, BordLRo							;if White is at last row -
			bge borderrb							; - proceed to check right border
			
				tst r3
				sxt r2	
				div #20, r2
				cmp r3, #0						;if White is at left border - 
				beq borderrb						; - proceed to check right border
				
					mov r0, r3					
					add #16, r3
					add #16, r3	
					cmp (r3), #0				;if left leap tile is occupied - 
					bne borderrb					; - proceed to check right border
					
						br packRec5				;found a legal move, wrap function
					
		;Black right border check:
		
	borderrb:	
			mov r0, r3
			sxt r2
			div #20, r2
			cmp r3, #16							;if on right border - 
			beq nextb								;proceed to nextB tile
			
		;the label signifies a situation where we want to check if Black player can proceed to the right diagonal, when we know he is not on the right border
			
	tilerb:
			mov r0, r3
			add #22, r3
			cmp (r3), #1			
			bgt nextb								;if right move tile has Black, proceed to nextB tile
			
				beq leaprb							;if right move tile has White, proceed to check right leap 
				
				br packRec5							;found a legal move, wrap function
				
		;checks if player can leap (eat) the playpiece on its right
			
	leaprb:	
			cmp r3, BordLRo							;if White is at last row - 			
			bge nextb								; - proceed to nextB tile
			
				tst r3
				sxt r2
				div #20, r2
				cmp r3, #16						;if White is at right border - 
				beq nextb							;proceed to nextB tile
				
					mov r0, r3
					add #22, r3					
					add #22, r3					
					cmp (r3), #0				;if right leap tile is occupied - 
					bne nextb						; - proceed to nextB tile
					
					br packRec5					;found a legal move, wrap function
					
		;checks next tile for moves.
						
	nextb:
			sub #2, r0								;going from end to start, each tile a word (so *2* bytes)
			cmp r0, BoardB
			bge loopb
				br .+22
		;unfold routine and Empty the stack
				
	packRec5:		
				sub #Board, r3
				sub #Board, r0
				mov r0, SrcPos
				mov r3, DstPos
				mov (sp)+, r4
				mov (sp)+, r3
				mov (sp)+, r2
				mov (sp)+, r1
				mov (sp)+, r0		
				rts pc
		

		;a loop for counting possible moves in case player is White			
			
	loopw:		
			cmp (r0), r4					;checks wether current tile has a White playpiece
			bne nextw						;if not checks next tile
			
				mov r0, r3						;
				sxt r2							;
				div #20, r2						;finds the reminders of the index, each even reminder between 0 - 20 (excluding) indicates a different horizontal location
			
				cmp r3, #0
				beq tilerw					;if it's right by the left ledge, move is illegal, there's no need to check if next to right ledge, since it is 
											;obviously by the left ledge.
			
			mov r0, r3					
			sub #22, r3				
			
			cmp (r3), #1				;if space has a White playpiece, it cannot jump there
			beq borderrw
				cmp (r3), #2			;if space has a Black playpiece try and initiate eat
				beq leaplw					
					br packRec5			;found a legal move, wrap function
	
		;checks if player can leap (eat) the playpiece on its left
	
	leaplw:
			tst r3
			sxt r2						
			div #20, r2						;finds the reminders of the index, to determine if close to the left
			
			cmp r3, #0
			beq borderrw					;if it's right by the left ledge, move is illegal

				mov r0,r3					;otherwise, check if close to ledge has destroyed r2, we have to recreate the checked index and find now the third 
				sub #22, r3				;diagonal tile away from checked tile
				sub #22, r3				;
				cmp r3, BoardB
				blt borderrw				;if index is negative that must mean eating would get the piece out of bounds.
				
					cmp (r3), #0		;if space is Empty count as eat
					bne borderrw
						br packRec5		;found a legal move, wrap function
			
		;checks if playpiece is on the right border (check if can jump to the right)
		
	borderrw:
			mov r0, r3						;
			sxt r2							;
			div #20, r2						;finds the reminders of the index, each even reminder between 0 - 20 (excluding) indicates a different horizontal location
						
			cmp r3, #16
			beq nextw						;if it's right by the right ledge, move is illegal, check the next tile
			
		;the label signifies a situation where we want to check if Black player can proceed to the right diagonal, when we know he is not on the right border
			
			
	tilerw:
			mov r0, r3						;
			sub #16, r3					;
			cmp (r3), #1				;if space has a White playpiece, it cannot jump there
			beq nextw
				cmp (r3), #2			;if space has a Black playpiece try and initiate eat
				beq leaprw
					br packRec5			;found a legal move, wrap function
		
		;checks if player can leap (eat) the playpiece on its left
	
	leaprw:	
			tst r3
			sxt r2						
			div #20, r2						;finds the reminders of the index, to determine if close to the right
			
			cmp r3, #16
			beq nextw						;if it's right by the right ledge, move is illegal
			
				mov r0,r3					;otherwise, check if close to ledge has destroyed r2, we have to recreate the checked index and find now the third 
				sub #16, r3				;diagonal tile away from checked tile
				sub #16, r3				;
				cmp r3, BoardB				;
				blt nextw					;if index is negative, that must mean eating would get the piece out of bounds.
			
				cmp (r3), #0			;if space is Empty count as eat
				bne nextw
					br packRec5			;found a legal move, wrap function

		;check next tile index
			
	nextw:	
			add #2, r0						;check nextW tile
			cmp r0, BoardE					;if index is 176 board has been scanned top to bottom -> halt
			ble loopw
				br packRec5					;exit function



			

.=torg+20000

Board:						;game's board for the duration of the game
.word 0,2,0,2,0,2,0,2
.word 2,0,2,0,2,0,2,0
.word 0,2,0,2,0,2,0,2
.word 0,0,0,0,0,0,0,0
.word 0,0,0,0,0,0,0,0
.word 1,0,1,0,1,0,1,0
.word 0,1,0,1,0,1,0,1
.word 1,0,1,0,1,0,1,0

BoardSt:					;clean start board for restarting game
.word 0,2,0,2,0,2,0,2
.word 2,0,2,0,2,0,2,0
.word 0,2,0,2,0,2,0,2
.word 0,0,0,0,0,0,0,0
.word 0,0,0,0,0,0,0,0
.word 1,0,1,0,1,0,1,0
.word 0,1,0,1,0,1,0,1
.word 1,0,1,0,1,0,1,0

Player:.blkw 1				;current player's turn
Steps:.blkw 1				;depth of recursion check of minimax algorithm

;output
SrcPos: .blkw 1				;holds index for tile from which piece is gonna be moved (only used for pc moves)
DstPos: .blkw 1				;holds index of destination tile of playpiece moved (only used for pc moves)
WinParam: .blkw 1			;holds WP for current calculated move for CPU

input: .blkw 31				;array that holds the characters of the command input by user
	   .byte 0  		;up to 50(decimal) chars	
.even
roleW: .blkw 1				;is 1 if white is played by human ; 1 for CPU
timeW: .blkw 1				;holds time set for white player's turn
roleB: .blkw 1				;is 1 if black is played by human ; 0 for CPU
timeB: .blkw 1				;holds time set for Black player's turn
gameStat: .blkw 1			;flag that is up when game is in progress
enter?: .blkw 1				;flag that indicates a command has been entered
moved?: .blkw 1				;flag that indicates wether exeMove has initiated any moves

.even
clockCounter:	.word 0		;number of clock interrupt since turn has started
currPTime:		.word 5000	;time for current turn
timeUp:			.word 0		;flag that indicates time for turn is up
stepInvalid:	.word 0		;flag that is 1 if recursion run has stopped in the middle though to time being up


;strings for printing

STtime1:		.ascii <Time left: \0>
.even
STtime2:		.ascii < seconds\0>
.even
STtime3:		.ascii <0.0\0>
.even
STstop1:		.ascii <WP for \0>
.even
STstop2:		.ascii < player is \0>
.even
STstop3:		.ascii < player wins!\0>
.even
STstopW1:		.ascii <white\0>
.even
STstopW2:		.ascii <White\0>
.even
STstopB1:		.ascii <black\0>
.even
STstopB2:		.ascii <Black\0>
.even
STtie:			.ascii <It's a tie!\0>
.even
STmove1:		.ascii < Human move took \0>
.even
STmove2:		.ascii < seconds\0>
.even								

openMsg: .ascii<Welcome to 315849919 and 208543538 checkers game!\r\n\0>
.even 
newRow: .ascii<\r\n$ \0>
.even
startMsg: .ascii<Starting a new game\r\n\r\n\0>
.even
startM_W: .ascii<White player is \0>
.even
startM_B: .ascii<Black player is \0>
.even
Human: .ascii<Human\0>
.even
Computer: .ascii<Computer\0>
.even
with: .ascii< with \0>
.even
secondsW: .blkw 8					;label used to hold and calculate time in seconds for move for white player
		  .byte 0
.even
secondsB: .blkw 8					;label used to hold and calculate time in seconds for move for Black player
		  .byte 0
.even
startM2: .ascii< seconds per move\r\n\r\n\0>
.even			
cntExe1: .ascii<Cannot execute "\0>
.even
cntExe2: .ascii<".\r\n\0>
.even
boardLO: .ascii<Board layout: \r\n\r\n\0>
.even
curP_msg: .ascii<Current player: \0>
.even
endMsg: .ascii< is out of time. Game over.\r\n\0>
.even
comMove:.ascii< Computer move took \0>

. = torg + 30000
.word 0
rate:			.word 1000
